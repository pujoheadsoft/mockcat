# mockcat ライブラリ 技術レポート

## 概要
`mockcat` は Haskell 用の軽量なモッキング／スタブ DSL です。左から右へのパイプ表記 `arg |> ... |> result` で期待される適用（ケース）を記述し、直接関数スタブを作るか、Template Haskell による型クラスモック (`makeMock` / `makePartialMock`) を生成して `runMockT` 内で実行・検証します。設計上は「明示的で小さな表現領域」「遅延評価と並行性を尊重する記録」を重視しています（詳細は README を参照）。

- バージョン: 0.6.0.0
- ライセンス: MIT

## 公開 API（主要）
- `createStubFn` / `createMockFn` / `createNamedMockFn` / `createMockFnIO`
- `to`, `onCase`, `cases`, `casesIO`
- `shouldApplyTo`, `shouldApplyTimes`, `shouldApplyInOrder`, `shouldApplyInPartialOrder` 等の検証ヘルパ
- `MockT`、`runMockT`、`expectApplyTimes`（legacy 名: `applyTimesIs`）、`neverApply`
- Template Haskell: `makeMock`, `makePartialMock`（詳細は `Test.MockCat.TH`）

## 主要な実装・型の解説

- `createMockFn`（概念）
  - 実装抜粋（参照）:

```135:148:/home/kenji/source/haskell/mockcat/src/Test/MockCat/Mock.hs
createMockFn ::
  ( MonadIO m
  , CreateMock p
  , MockBuilder (ToMockParams p) fn verifyParams
  , Typeable verifyParams
  , Typeable fn
  ) =>
  p ->
  m fn
createMockFn p = do
  let params = toParams p
  (fn, verifier) <- build Nothing params
  registerStub Nothing verifier fn
```

  - `createMockFn` は受け取ったパラメータチェインを `MockBuilder` に渡して関数と検証器 (`verifier`) を生成し、`registerStub` を通じて検証メタデータを関数に紐付ける。表面上は純粋関数を返すが、生成過程で IO を用いて内部データ（適用記録や検証器）を準備する。

- `registerStub` と `wrapUnitStub`
  - `registerStub` は返値を強制評価した際に適用を記録するためのラッパー処理を行う。モックが「引数無し（params ~ ()）」の場合は特別処理で `UnitMeta` を生成して追跡を行う。
  - 実装抜粋（参照）:

```275:291:/home/kenji/source/haskell/mockcat/src/Test/MockCat/Mock.hs
wrapUnitStub ::
  forall fn.
  Typeable fn =>
  IORef (AppliedRecord ()) ->
  UnitMeta ->
  fn ->
  fn
wrapUnitStub ref meta value =
  let trackedValue = perform $ do
        guardActive <- isGuardActive meta
        if guardActive || isIOType (Proxy :: Proxy fn)
          then pure value
          else do
            markUnitUsed meta
            appendAppliedParams ref ()
            pure value
   in value `seq` trackedValue
```

  - `wrapUnitStub` の重要点:
    - 遅延評価を尊重し、返値が評価された瞬間に適用が記録される（unevaluated results はカウントされない）。
    - `isIOType` 判定により IO 型の返り値は扱いを変え、評価タイミングの違いに対応する。

- `MockT` と `runMockT`
  - `MockT` は内部的に `ReaderT (TVar [Definition])` を使う薄いラッパーで、テストスコープごとに新しい `TVar` を生成してスタブ定義を蓄積し、`runMockT` の終了時にすべての定義に対して検証を実行する。
  - 実装抜粋（参照）:

```109:115:/home/kenji/source/haskell/mockcat/src/Test/MockCat/MockT.hs
runMockT :: MonadIO m => MockT m a -> m a
runMockT (MockT r) = do
  ref <- liftIO $ newTVarIO []
  a <- runReaderT r ref
  defs <- liftIO $ readTVarIO ref
  for_ defs (\(Definition _ mock verify) -> liftIO $ verify mock)
  pure a
```

  - 並行性と安全性:
    - 定義の追加やカウント更新は STM の `modifyTVar'` を用いており、並列スレッド間での漏れや重複計上を防ぐ実装（README にも注記）。
    - `runMockT` ごとに独立した `TVar` を使用するためテスト間で状態が共有されない。

- 期待値指定（Cases / onCase / cases）
  - `onCase` / `cases` で複数ケースを登録でき、同一引数に対して発生順に異なる返値を与えることも可能（sticky tail 動作）。
  - `createMockFnIO` は `buildIO` で IO モノード専用のビルダを作り、結果を任意の `MonadIO` に持ち上げるための `LiftFunTo` を利用している。

## 遅延評価・並行性に関する挙動
- 呼び出しが「記録される」タイミングは返値が評価された瞬間（Haskell の遅延評価を尊重）。
- カウントは `modifyTVar'` などの STM によって原子的に更新されるため、複数スレッドからの同時評価でも正確な合計が得られる（プロパティテストあり）。
- Order 系の検証（`shouldApplyInOrder`）は評価順に基づくため、評価のタイミング次第で順序が変わり得る点に注意。README にも明記あり。

## Template Haskell（型クラスモック）の要点
- `makeMock` / `makePartialMock` は型クラス定義を解析して `_` プレフィックス付きのスタブ関数を生成し、`MockT` のインスタンスを用意する。生成されたスタブは `MockBuilder` 制約で述語的にパラメータを受け取る形になる（README の「Code generated by makeMock」を参照）。

## 使用例（Summary）
- 単純なスタブ:
```haskell
f <- createStubFn $ "input" |> 42
f "input" `shouldBe` 42
f `shouldApplyTo` "input"
```
- 型クラスモック（`runMockT`）:
```haskell
result <- runMockT do
  _putKV ("k" |> "v" |> ())
  _getKV ("k" |> Just "v")
  program
```

## 実装上の注目点・設計判断
- 明示的な小ささ: DSL は `|>` と少数の組合せ子に絞られており、学習コストが低い。
- 遅延評価尊重: 記録タイミングを返値の評価に委ねることで「副作用を無理に評価させない」設計。
- 並行性に対する安全措置: STM (`modifyTVar'`) や `MonadUnliftIO` 対応（`MockT` の `MonadUnliftIO` 実装）により、非同期実行を安全に扱う。
- テスト設計向けの妥協: グローバルな隠れた状態を持たないことでテストの独立性を保証する一方、大規模な振る舞いシミュレート用途には向かないというトレードオフ。

## 既知の制限・注意事項
- 結果が評価されないまま終わると呼び出しはカウントされない — テスト内で結果を強制評価する必要がある場合がある。
- 非常に高頻度な呼び出しを大量に計測するようなベンチ用途にはオーバーヘッドが出る可能性がある（README にも注意）。

## PDF 化（環境で実行したい場合）
ローカル環境で Markdown を PDF に変換するための一例（pandoc + wkhtmltopdf 等）:

```bash
# pandoc を使う例（推奨）
pandoc reports/technical-report.md -o reports/technical-report.pdf --pdf-engine=pdflatex

# wkhtmltopdf を使う例（HTML 経由）
pandoc reports/technical-report.md -o reports/technical-report.html
wkhtmltopdf reports/technical-report.html reports/technical-report.pdf
```

この実行は CI／手元環境で行ってください（この実行環境で自動的に実行は行いません）。

---
作成日: 2025-11-24


