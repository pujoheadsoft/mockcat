diff --git a/diff.patch b/diff.patch
index 96c969e..e69de29 100644
--- a/diff.patch
+++ b/diff.patch
@@ -1,207 +0,0 @@
-diff --git a/src/Test/MockCat/Internal/Builder.hs b/src/Test/MockCat/Internal/Builder.hs
-index e0b905f..4709b36 100644
---- a/src/Test/MockCat/Internal/Builder.hs
-+++ b/src/Test/MockCat/Internal/Builder.hs
-@@ -69,11 +69,11 @@ type family CurriedFn (mode :: k) (args :: Type) (r :: Type) :: Type where
- class ModeSpec mode => BuildCurriedGeneric mode args r fn | mode args r -> fn where
-   buildGeneric :: InputFn mode args r -> fn
- 
--instance (ModeSpec mode, fn ~ (a -> ApplyMode mode r))
-+instance (ModeSpec mode, fn ~ (a -> ApplyMode mode r), ToParam a, Target a ~ a, Eq a)
-       => BuildCurriedGeneric mode (Param a) r fn where
--  buildGeneric f a = finalize @mode @r (f (param a))
-+  buildGeneric f = \a -> finalize @mode @r (f (param a))
- 
--instance (ModeSpec mode, BuildCurriedGeneric mode rest r fn, fn' ~ (a -> fn))
-+instance (ModeSpec mode, BuildCurriedGeneric mode rest r fn, fn' ~ (a -> fn), ToParam a, Target a ~ a, Eq a)
-       => BuildCurriedGeneric mode (Param a :> rest) r fn' where
-   buildGeneric input a = buildGeneric @mode @rest @r (input . (\rest -> p a :> rest))
- -- ------------
-@@ -248,7 +248,7 @@ incrementCount key list =
- runCase :: Cases a b -> [a]
- runCase (Cases s) = execState s []
- 
--p :: a -> Param a
-+p :: (ToParam a, Target a ~ a) => a -> Param a
- p = param
- 
- class StubBuilder params fn | params -> fn where
-diff --git a/src/Test/MockCat/Mock.hs b/src/Test/MockCat/Mock.hs
-index 6b4dc47..3d8f6de 100644
---- a/src/Test/MockCat/Mock.hs
-+++ b/src/Test/MockCat/Mock.hs
-@@ -100,6 +100,9 @@ createConstantStubFn ::
-   ( MonadIO m
-   , MockBuilder (Param b) b ()
-   , Typeable b
-+  , ToParam b
-+  , Target b ~ b
-+  , Eq b
-   ) =>
-   b ->
-   m b
-@@ -110,6 +113,9 @@ createNamedConstantStubFn ::
-   ( MonadIO m
-   , MockBuilder (Param b) b ()
-   , Typeable b
-+  , ToParam b
-+  , Target b ~ b
-+  , Eq b
-   ) =>
-   MockName ->
-   b ->
-diff --git a/src/Test/MockCat/Param.hs b/src/Test/MockCat/Param.hs
-index 7258594..7f83d91 100644
---- a/src/Test/MockCat/Param.hs
-+++ b/src/Test/MockCat/Param.hs
-@@ -7,6 +7,10 @@
- {-# LANGUAGE TypeFamilyDependencies #-}
- {-# LANGUAGE TypeOperators #-}
- {-# LANGUAGE UndecidableInstances #-}
-+{-# LANGUAGE GADTs #-}
-+{-# LANGUAGE MagicHash #-}
-+{-# LANGUAGE TypeFamilies #-}
-+
- {-# OPTIONS_GHC -Wno-redundant-constraints #-}
- 
- -- | This module is a parameter of the mock function.
-@@ -26,23 +30,54 @@ module Test.MockCat.Param
-     ReturnOf,
-     ProjectionReturn,
-     projReturn,
--    returnValue
-+    returnValue,
-+    ToParam(..),
-+    Target,
-   )
- where
- 
- import Test.MockCat.Cons ((:>) (..))
- import Unsafe.Coerce (unsafeCoerce)
- import Prelude hiding (any)
-+import GHC.Exts ( reallyUnsafePtrEquality#, Int(I#) )
-+
-+data Param v where
-+  ExpectValue :: Eq v => v -> Param v
-+  ExpectCondition :: (v -> Bool) -> String -> Param v
-+  ExpectRef :: v -> Param v
-+
-+matchParam :: Param v -> v -> Bool
-+matchParam (ExpectValue a) b = a == b
-+matchParam (ExpectCondition f _) a = f a
-+matchParam (ExpectRef e) a = pointerEq e a
-+
-+pointerEq :: a -> a -> Bool
-+pointerEq a b = I# (reallyUnsafePtrEquality# (unsafeCoerce a) (unsafeCoerce b)) == 1
-+
-+type family Target a where
-+  Target (Param a) = a
-+  Target (a -> b) = a -> b
-+  Target a = a
-+
-+class ToParam a where
-+  toParam :: a -> Param (Target a)
-+
-+instance {-# OVERLAPPING #-} ToParam (Param a) where
-+  toParam = id
-+
-+instance {-# OVERLAPPING #-} ToParam (a -> b) where
-+  toParam = ExpectRef
-+
-+instance {-# OVERLAPPABLE #-} (Eq a, Target a ~ a) => ToParam a where
-+  toParam = ExpectValue
-+
- 
--data Param v
--  = ExpectValue v
--  | ExpectCondition (v -> Bool) String
- 
--instance (Eq a) => Eq (Param a) where
--  (ExpectValue a) == (ExpectValue b) = a == b
--  (ExpectValue a) == (ExpectCondition m2 _) = m2 a
--  (ExpectCondition m1 _) == (ExpectValue b) = m1 b
--  (ExpectCondition _ l1) == (ExpectCondition _ l2) = l1 == l2
-+-- instance (Eq a) => Eq (Param a) where
-+--   (ExpectValue a) == (ExpectValue b) = a == b
-+--   (ExpectValue a) == (ExpectCondition m2 _) = m2 a
-+--   (ExpectCondition m1 _) == (ExpectValue b) = m1 b
-+--   (ExpectCondition _ l1) == (ExpectCondition _ l2) = l1 == l2
- 
- type family ShowResult a where
-   ShowResult String = String
-@@ -66,23 +101,23 @@ value :: Param v -> v
- value (ExpectValue a) = a
- value _ = error "not implement"
- 
--param :: v -> Param v
--param = ExpectValue
-+param :: (ToParam v, Target v ~ v) => v -> Param v
-+param = toParam
- 
- class ConsGen a b r | a b -> r where
-   (|>) :: a -> b -> r
- 
--instance {-# OVERLAPPING #-} (Param a ~ a', (Param b :> c) ~ bc) => ConsGen a (Param b :> c) (a' :> bc) where
-+instance {-# OVERLAPPING #-} (Param a ~ a', (Param b :> c) ~ bc, ToParam a, Target a ~ a, Eq a) => ConsGen a (Param b :> c) (a' :> bc) where
-   (|>) a = (:>) (param a)
- instance {-# OVERLAPPING #-} ((Param b :> c) ~ bc) => ConsGen (Param a) (Param b :> c) (Param a :> bc) where
-   (|>) = (:>)
- instance ConsGen (Param a) (Param b) (Param a :> Param b) where
-   (|>) = (:>)
--instance {-# OVERLAPPABLE #-} ((Param b) ~ b') => ConsGen (Param a) b (Param a :> b') where
-+instance {-# OVERLAPPABLE #-} ((Param b) ~ b', ToParam b, Target b ~ b, Eq b) => ConsGen (Param a) b (Param a :> b') where
-   (|>) a b = (:>) a (param b)
--instance {-# OVERLAPPABLE #-} ((Param a) ~ a') => ConsGen a (Param b) (a' :> Param b) where
-+instance {-# OVERLAPPABLE #-} ((Param a) ~ a', ToParam a, Target a ~ a, Eq a) => ConsGen a (Param b) (a' :> Param b) where
-   (|>) a = (:>) (param a)
--instance {-# OVERLAPPABLE #-} (Param a ~ a', Param b ~ b') => ConsGen a b (a' :> b') where
-+instance {-# OVERLAPPABLE #-} (Param a ~ a', Param b ~ b', ToParam a, Target a ~ a, Eq a, ToParam b, Target b ~ b, Eq b) => ConsGen a b (a' :> b') where
-   (|>) a b = (:>) (param a) (param b)
- 
- infixr 8 |>
-diff --git a/src/Test/MockCat/Verify.hs b/src/Test/MockCat/Verify.hs
-index ae1ba98..b201c73 100644
---- a/src/Test/MockCat/Verify.hs
-+++ b/src/Test/MockCat/Verify.hs
-@@ -13,6 +13,7 @@
- {-# LANGUAGE DataKinds #-}
- {-# LANGUAGE MultiParamTypeClasses #-}
- {-# OPTIONS_GHC -Wno-redundant-constraints #-}
-+{-# LANGUAGE InstanceSigs #-}
- module Test.MockCat.Verify where
- 
- import Test.MockCat.Internal.Types
-@@ -45,7 +46,7 @@ class Verify params input where
-     input ->
-     IO ()
- 
--instance (Eq a, Show a) => Verify (Param a) a where
-+instance (Eq a, Show a, ToParam a, Target a ~ a, Eq (Param a)) => Verify (Param a) a where
-   shouldApplyTo v a = verify v (MatchAny (param a))
- 
- instance (Eq a, Show a) => Verify a a where
-@@ -103,10 +104,13 @@ class VerifyCount countType params a where
-     a ->
-     IO ()
- 
--instance VerifyCount CountVerifyMethod (Param a) a where
-+instance (ToParam a, Target a ~ a, Eq a) => VerifyCount CountVerifyMethod (Param a) a where
-   shouldApplyTimes v count a = verifyCount v (param a) count
- 
--instance VerifyCount Int (Param a) a where
-+instance (ToParam a, Target a ~ a, Eq a) => VerifyCount Int (Param a) a where
-+  shouldApplyTimes :: (MockResolvable m, ResolvableParams m ~ Param a, HasCallStack,
-+    Eq (Param a)) =>
-+    m -> Int -> a -> IO ()
-   shouldApplyTimes v count a = verifyCount v (param a) (Equal count)
- 
- instance {-# OVERLAPPABLE #-} VerifyCount CountVerifyMethod a a where
-@@ -171,7 +175,7 @@ class VerifyOrder params input where
-   -- As long as the order matches, the verification succeeds.
-   shouldApplyInPartialOrder :: (MockResolvable m, ResolvableParams m ~ params, HasCallStack) => m -> [input] -> IO ()
- 
--instance (Eq a, Show a) => VerifyOrder (Param a) a where
-+instance (Eq a, Show a, ToParam a, Target a ~ a, Eq (Param a)) => VerifyOrder (Param a) a where
-   shouldApplyInOrder v a = verifyOrder ExactlySequence v $ param <$> a
-   shouldApplyInPartialOrder v a = verifyOrder PartiallySequence v $ param <$> a
- 
diff --git a/src/Test/MockCat/AssociationList.hs b/src/Test/MockCat/AssociationList.hs
index 3f057c3..bc8c467 100644
--- a/src/Test/MockCat/AssociationList.hs
+++ b/src/Test/MockCat/AssociationList.hs
@@ -1,33 +1,34 @@
 module Test.MockCat.AssociationList 
- (AssociationList, empty, insert, lookup, member, (!?), update) where
+(AssociationList, empty, insert, lookup, member, (!?), update) where
 
 import Prelude hiding (lookup)
 import Data.Maybe (isJust)
+import Test.MockCat.Param (ParamsEq, paramsEq)
 
 type AssociationList k a = [(k, a)]
 
 empty :: AssociationList k a
 empty = []
 
-insert :: Eq k => k -> a -> AssociationList k a -> AssociationList k a
+insert :: ParamsEq k => k -> a -> AssociationList k a -> AssociationList k a
 insert key value [] = [(key, value)]
 insert key value ((k, v) : xs)
-  | key == k  = (key, value) : xs
+  | paramsEq key k  = (key, value) : xs
   | otherwise = (k, v) : insert key value xs
 
-lookup :: Eq k => k -> AssociationList k a -> Maybe a
+lookup :: ParamsEq k => k -> AssociationList k a -> Maybe a
 lookup _ [] = Nothing
 lookup key ((k, a) : xs)
-  | key == k  = Just a
+  | paramsEq key k  = Just a
   | otherwise = lookup key xs
 
-member :: Eq k => k -> AssociationList k a -> Bool
+member :: ParamsEq k => k -> AssociationList k a -> Bool
 member k list = isJust (lookup k list)
 
-(!?) :: Eq k => AssociationList k a -> k -> Maybe a
+(!?) :: ParamsEq k => AssociationList k a -> k -> Maybe a
 (!?) = flip lookup
 
-update :: Eq k => (a -> a) -> k -> AssociationList k a -> AssociationList k a
+update :: ParamsEq k => (a -> a) -> k -> AssociationList k a -> AssociationList k a
 update f key list =
   case list !? key of
     Just value -> insert key (f value) list
diff --git a/src/Test/MockCat/Internal/Builder.hs b/src/Test/MockCat/Internal/Builder.hs
index e0b905f..c594e12 100644
--- a/src/Test/MockCat/Internal/Builder.hs
+++ b/src/Test/MockCat/Internal/Builder.hs
@@ -69,11 +69,11 @@ type family CurriedFn (mode :: k) (args :: Type) (r :: Type) :: Type where
 class ModeSpec mode => BuildCurriedGeneric mode args r fn | mode args r -> fn where
   buildGeneric :: InputFn mode args r -> fn
 
-instance (ModeSpec mode, fn ~ (a -> ApplyMode mode r))
+instance (ModeSpec mode, fn ~ (a -> ApplyMode mode r), ToParam a, Target a ~ a)
       => BuildCurriedGeneric mode (Param a) r fn where
-  buildGeneric f a = finalize @mode @r (f (param a))
+  buildGeneric f = \a -> finalize @mode @r (f (param a))
 
-instance (ModeSpec mode, BuildCurriedGeneric mode rest r fn, fn' ~ (a -> fn))
+instance (ModeSpec mode, BuildCurriedGeneric mode rest r fn, fn' ~ (a -> fn), ToParam a, Target a ~ a)
       => BuildCurriedGeneric mode (Param a :> rest) r fn' where
   buildGeneric input a = buildGeneric @mode @rest @r (input . (\rest -> p a :> rest))
 -- ------------
@@ -225,13 +225,13 @@ appendAppliedParams ref inputParams = do
         }
     in (newRecord, ()))
 
-readAppliedCount :: Eq params => IORef (AppliedRecord params) -> params -> IO Int
+readAppliedCount :: ParamsEq params => IORef (AppliedRecord params) -> params -> IO Int
 readAppliedCount ref params = do
   record <- readIORef ref
   let count = appliedParamsCounter record
   pure $ fromMaybe 0 (lookup params count)
 
-incrementAppliedParamCount :: Eq params => IORef (AppliedRecord params) -> params -> IO ()
+incrementAppliedParamCount :: ParamsEq params => IORef (AppliedRecord params) -> params -> IO ()
 incrementAppliedParamCount ref inputParams = do
   atomicModifyIORef' ref (\AppliedRecord {appliedParamsList, appliedParamsCounter} ->
     let newRecord = AppliedRecord {
@@ -240,7 +240,7 @@ incrementAppliedParamCount ref inputParams = do
         }
     in (newRecord, ()))
 
-incrementCount :: Eq k => k -> AppliedParamsCounter k -> AppliedParamsCounter k
+incrementCount :: ParamsEq k => k -> AppliedParamsCounter k -> AppliedParamsCounter k
 incrementCount key list =
   if member key list then update (+ 1) key list
   else insert key 1 list
@@ -248,7 +248,7 @@ incrementCount key list =
 runCase :: Cases a b -> [a]
 runCase (Cases s) = execState s []
 
-p :: a -> Param a
+p :: (ToParam a, Target a ~ a) => a -> Param a
 p = param
 
 class StubBuilder params fn | params -> fn where
@@ -301,7 +301,7 @@ type ParamConstraints params args r =
   , ProjectionReturn params
   , ArgsOf params ~ args
   , ReturnOf params ~ Param r
-  , Eq args
+  , ParamsEq args
   , Show args
   )
 
@@ -309,13 +309,13 @@ extractReturnValue :: ParamConstraints params args r => Maybe MockName -> params
 extractReturnValue name params inputParams = do
   validateOnly name (projArgs params) inputParams `seq` returnValue params
 
-validateOnly :: (Eq a, Show a) => Maybe MockName -> a -> a -> ()
+validateOnly :: (ParamsEq a, Show a) => Maybe MockName -> a -> a -> ()
 validateOnly name expected actual = do
   validateParamsPure name expected actual
 
-validateParamsPure :: (Eq a, Show a) => Maybe MockName -> a -> a -> ()
+validateParamsPure :: (ParamsEq a, Show a) => Maybe MockName -> a -> a -> ()
 validateParamsPure name expected actual =
-  if expected == actual
+  if paramsEq expected actual
     then ()
     else errorWithoutStackTrace $ message name expected actual
 
@@ -339,7 +339,7 @@ findReturnValuePure ::
   args ->
   Maybe r
 findReturnValuePure paramsList inputParams = do
-  let matchedParams = filter (\params -> projArgs params == inputParams) paramsList
+  let matchedParams = filter (\params -> projArgs params `paramsEq` inputParams) paramsList
   case matchedParams of
     [] -> Nothing
     _ -> do
@@ -363,7 +363,7 @@ singleInvocationStep ::
   InvocationStep args r
 singleInvocationStep name params inputParams record@AppliedRecord {appliedParamsList, appliedParamsCounter} = do
   let expected = projArgs params
-  if expected == inputParams
+  if expected `paramsEq` inputParams
     then
       (AppliedRecord {
         appliedParamsList = appliedParamsList ++ [inputParams]
@@ -379,7 +379,7 @@ casesInvocationStep ::
   InvocationStep args r
 casesInvocationStep name paramsList inputParams AppliedRecord {appliedParamsList, appliedParamsCounter} = do
   let newAppliedList = appliedParamsList ++ [inputParams]
-      matchedParams = filter (\params -> projArgs params == inputParams) paramsList
+      matchedParams = filter (\params -> projArgs params `paramsEq` inputParams) paramsList
       expectedArgs = projArgs <$> paramsList
    in case matchedParams of
         [] ->
diff --git a/src/Test/MockCat/Internal/Message.hs b/src/Test/MockCat/Internal/Message.hs
index 9bfc7f9..77b42fc 100644
--- a/src/Test/MockCat/Internal/Message.hs
+++ b/src/Test/MockCat/Internal/Message.hs
@@ -6,6 +6,7 @@ import Data.List (intercalate)
 import Data.Char (isLower)
 import Data.Text (pack, replace, unpack)
 import Test.MockCat.Internal.Types
+import Test.MockCat.Param (Param)
 
 message :: Show a => Maybe MockName -> a -> a -> String
 message name expected actual =
@@ -41,7 +42,7 @@ quoteToken s
   | not (null s) && isLower (head s) = '"' : s ++ "\""
   | otherwise = s
 
-verifyFailedMessage :: Show a => Maybe MockName -> AppliedParamsList a -> a -> VerifyFailed
+verifyFailedMessage :: Show a => Maybe MockName -> AppliedParamsList a -> Param a -> VerifyFailed
 verifyFailedMessage name appliedParams expected =
   VerifyFailed $
     intercalate
diff --git a/src/Test/MockCat/Internal/Types.hs b/src/Test/MockCat/Internal/Types.hs
index 2a8e0ea..4b284cd 100644
--- a/src/Test/MockCat/Internal/Types.hs
+++ b/src/Test/MockCat/Internal/Types.hs
@@ -15,9 +15,10 @@ import Control.Monad (ap)
 import Data.IORef (IORef)
 import Data.Maybe
 import GHC.IO (unsafePerformIO)
-import Test.MockCat.AssociationList (AssociationList)
+import Test.MockCat.AssociationList (AssociationList, lookup)
 import Prelude hiding (lookup)
 import Control.Monad.State ( State )
+import Test.MockCat.Param (Param, ParamsEq, paramsEq)
 
 newtype Verifier params = Verifier (IORef (AppliedRecord params))
 
@@ -28,7 +29,20 @@ data AppliedRecord params = AppliedRecord {
   appliedParamsList :: AppliedParamsList params,
   appliedParamsCounter :: AppliedParamsCounter params
 }
-  deriving (Eq, Show)
+  deriving (Show)
+
+instance ParamsEq params => Eq (AppliedRecord params) where
+  (AppliedRecord l1 c1) == (AppliedRecord l2 c2) =
+    listsEqual && countersEqual
+    where
+      listsEqual = length l1 == length l2 && and (zipWith paramsEq l1 l2)
+      countersEqual =
+        length c1 == length c2
+          && all
+            (\(k, v) -> case lookup k c2 of
+                Just v2 -> v == v2
+                Nothing -> False)
+            c1
 
 data CountVerifyMethod
   = Equal Int
@@ -74,7 +88,7 @@ data VerifyOrderResult a = VerifyOrderResult
 type Message = String
 
 -- verify
-data VerifyMatchType a = MatchAny a | MatchAll a
+data VerifyMatchType a = MatchAny (Param a) | MatchAll (Param a)
 
 type MockName = String
 
diff --git a/src/Test/MockCat/Mock.hs b/src/Test/MockCat/Mock.hs
index 6b4dc47..3d8f6de 100644
--- a/src/Test/MockCat/Mock.hs
+++ b/src/Test/MockCat/Mock.hs
@@ -100,6 +100,9 @@ createConstantStubFn ::
   ( MonadIO m
   , MockBuilder (Param b) b ()
   , Typeable b
+  , ToParam b
+  , Target b ~ b
+  , Eq b
   ) =>
   b ->
   m b
@@ -110,6 +113,9 @@ createNamedConstantStubFn ::
   ( MonadIO m
   , MockBuilder (Param b) b ()
   , Typeable b
+  , ToParam b
+  , Target b ~ b
+  , Eq b
   ) =>
   MockName ->
   b ->
diff --git a/src/Test/MockCat/Param.hs b/src/Test/MockCat/Param.hs
index 7258594..6f303b1 100644
--- a/src/Test/MockCat/Param.hs
+++ b/src/Test/MockCat/Param.hs
@@ -7,6 +7,10 @@
 {-# LANGUAGE TypeFamilyDependencies #-}
 {-# LANGUAGE TypeOperators #-}
 {-# LANGUAGE UndecidableInstances #-}
+{-# LANGUAGE GADTs #-}
+{-# LANGUAGE MagicHash #-}
+{-# LANGUAGE TypeFamilies #-}
+
 {-# OPTIONS_GHC -Wno-redundant-constraints #-}
 
 -- | This module is a parameter of the mock function.
@@ -26,23 +30,70 @@ module Test.MockCat.Param
     ReturnOf,
     ProjectionReturn,
     projReturn,
-    returnValue
+    returnValue,
+    ToParam(..),
+    Target,
+    matchParam,
+    ParamsEq(..),
   )
 where
 
 import Test.MockCat.Cons ((:>) (..))
 import Unsafe.Coerce (unsafeCoerce)
 import Prelude hiding (any)
+import GHC.Exts ( reallyUnsafePtrEquality#, Int(I#) )
+import Control.Monad.Trans.State (StateT)
+
+data Param v where
+  ExpectValue :: Eq v => v -> Param v
+  ExpectCondition :: (v -> Bool) -> String -> Param v
+  ExpectRef :: v -> Param v
+
+matchParam :: Param v -> v -> Bool
+matchParam (ExpectValue a) b = a == b
+matchParam (ExpectCondition f _) a = f a
+matchParam (ExpectRef e) a = pointerEq e a
+
+pointerEq :: a -> a -> Bool
+pointerEq a b = I# (reallyUnsafePtrEquality# (unsafeCoerce a) (unsafeCoerce b)) == 1
+
+type family Target a where
+  Target (Param a) = a
+  Target (a -> b) = a -> b
+  Target a = a
+
+class ToParam a where
+  toParam :: a -> Param (Target a)
+
+instance {-# OVERLAPPING #-} ToParam (Param a) where
+  toParam = id
+
+instance {-# OVERLAPPING #-} ToParam (a -> b) where
+  toParam = ExpectRef
+
+instance {-# OVERLAPPING #-} ToParam (IO a) where
+  toParam = ExpectRef
+
+instance {-# OVERLAPPING #-} ToParam (StateT s m a) where
+  toParam = ExpectRef
+
+instance {-# OVERLAPPABLE #-} (Target a ~ a, Eq a) => ToParam a where
+  toParam = ExpectValue
+
 
-data Param v
-  = ExpectValue v
-  | ExpectCondition (v -> Bool) String
 
-instance (Eq a) => Eq (Param a) where
+-- instance (Eq a) => Eq (Param a) where
+--   (ExpectValue a) == (ExpectValue b) = a == b
+--   (ExpectValue a) == (ExpectCondition m2 _) = m2 a
+--   (ExpectCondition m1 _) == (ExpectValue b) = m1 b
+--   (ExpectCondition _ l1) == (ExpectCondition _ l2) = l1 == l2
+instance Eq (Param a) where
   (ExpectValue a) == (ExpectValue b) = a == b
   (ExpectValue a) == (ExpectCondition m2 _) = m2 a
   (ExpectCondition m1 _) == (ExpectValue b) = m1 b
   (ExpectCondition _ l1) == (ExpectCondition _ l2) = l1 == l2
+  (ExpectRef r) == (ExpectRef s) = pointerEq r s
+  _ == _ = False
 
 type family ShowResult a where
   ShowResult String = String
@@ -66,23 +117,23 @@ value :: Param v -> v
 value (ExpectValue a) = a
 value _ = error "not implement"
 
-param :: v -> Param v
-param = ExpectValue
+param :: (ToParam v, Target v ~ v) => v -> Param v
+param = toParam
 
 class ConsGen a b r | a b -> r where
   (|>) :: a -> b -> r
 
-instance {-# OVERLAPPING #-} (Param a ~ a', (Param b :> c) ~ bc) => ConsGen a (Param b :> c) (a' :> bc) where
+instance {-# OVERLAPPING #-} (Param a ~ a', (Param b :> c) ~ bc, ToParam a, Target a ~ a) => ConsGen a (Param b :> c) (a' :> bc) where
   (|>) a = (:>) (param a)
 instance {-# OVERLAPPING #-} ((Param b :> c) ~ bc) => ConsGen (Param a) (Param b :> c) (Param a :> bc) where
   (|>) = (:>)
 instance ConsGen (Param a) (Param b) (Param a :> Param b) where
   (|>) = (:>)
-instance {-# OVERLAPPABLE #-} ((Param b) ~ b') => ConsGen (Param a) b (Param a :> b') where
+instance {-# OVERLAPPABLE #-} ((Param b) ~ b', ToParam b, Target b ~ b) => ConsGen (Param a) b (Param a :> b') where
   (|>) a b = (:>) a (param b)
-instance {-# OVERLAPPABLE #-} ((Param a) ~ a') => ConsGen a (Param b) (a' :> Param b) where
+instance {-# OVERLAPPABLE #-} ((Param a) ~ a', ToParam a, Target a ~ a) => ConsGen a (Param b) (a' :> Param b) where
   (|>) a = (:>) (param a)
-instance {-# OVERLAPPABLE #-} (Param a ~ a', Param b ~ b') => ConsGen a b (a' :> b') where
+instance {-# OVERLAPPABLE #-} (Param a ~ a', Param b ~ b', ToParam a, Target a ~ a, ToParam b, Target b ~ b) => ConsGen a b (a' :> b') where
   (|>) a b = (:>) (param a) (param b)
 
 infixr 8 |>
@@ -145,4 +196,43 @@ instance
   projReturn (_ :> rest) = projReturn rest
 
 returnValue :: (ProjectionReturn params, ReturnOf params ~ Param r) => params -> r
-returnValue = value . projReturn
\ No newline at end of file
+returnValue = value . projReturn
+
+
+-- | Class for equality-like comparison of recorded parameters.
+--   Instances implement matching semantics: for `Param` types use `matchParam`,
+--   for composed `(:>)` compare components recursively, and for `()` always true.
+class ParamsEq a where
+  paramsEq :: a -> a -> Bool
+
+instance ParamsEq () where
+  paramsEq () () = True
+
+-- extract underlying value if available (ExpectValue / ExpectRef)
+unParamValue :: Param v -> Maybe v
+unParamValue (ExpectValue v) = Just v
+unParamValue (ExpectRef v) = Just v
+unParamValue (ExpectCondition _ _) = Nothing
+
+instance {-# OVERLAPPING #-} ParamsEq (Param a) where
+  paramsEq expected actual =
+    case expected of
+      ExpectCondition f _ ->
+        case unParamValue actual of
+          Just v -> f v
+          Nothing -> False
+      ExpectValue v ->
+        case unParamValue actual of
+          Just a -> v == a
+          Nothing -> False
+      ExpectRef r ->
+        case unParamValue actual of
+          Just a -> pointerEq r a
+          Nothing -> False
+
+instance {-# OVERLAPPING #-} (ParamsEq a, ParamsEq b) => ParamsEq (a :> b) where
+  paramsEq (x :> xs) (y :> ys) = paramsEq x y && paramsEq xs ys
+
+-- Fallback for types that have Eq (non-Param types)
+instance {-# INCOHERENT #-} Eq a => ParamsEq a where
+  paramsEq = (==)
\ No newline at end of file
diff --git a/src/Test/MockCat/Verify.hs b/src/Test/MockCat/Verify.hs
index ae1ba98..00e972a 100644
--- a/src/Test/MockCat/Verify.hs
+++ b/src/Test/MockCat/Verify.hs
@@ -13,13 +13,14 @@
 {-# LANGUAGE DataKinds #-}
 {-# LANGUAGE MultiParamTypeClasses #-}
 {-# OPTIONS_GHC -Wno-redundant-constraints #-}
+{-# LANGUAGE InstanceSigs #-}
 module Test.MockCat.Verify where
 
 import Test.MockCat.Internal.Types
 import Control.Monad (guard, when)
 import Data.Function ((&))
 import Data.IORef (IORef, readIORef)
-import Data.List (elemIndex, intercalate)
+import Data.List (intercalate)
 import Data.Maybe
 import Test.MockCat.Param
 import Prelude hiding (lookup)
@@ -45,15 +46,11 @@ class Verify params input where
     input ->
     IO ()
 
-instance (Eq a, Show a) => Verify (Param a) a where
+instance (Show a, ToParam a, Target a ~ a) => Verify a a where
   shouldApplyTo v a = verify v (MatchAny (param a))
 
-instance (Eq a, Show a) => Verify a a where
-  shouldApplyTo v a = verify v (MatchAny a)
-
 verify ::
   ( MockResolvable m
-  , Eq (ResolvableParams m)
   , Show (ResolvableParams m)
   ) =>
   m ->
@@ -65,12 +62,12 @@ verify m matchType = do
   let result = doVerify mockName appliedParamsList matchType
   result & maybe (pure ()) (\(VerifyFailed msg) -> errorWithoutStackTrace msg)
 
-doVerify :: (Eq a, Show a) => Maybe MockName -> AppliedParamsList a -> VerifyMatchType a -> Maybe VerifyFailed
+doVerify :: (Show a) => Maybe MockName -> AppliedParamsList a -> VerifyMatchType a -> Maybe VerifyFailed
 doVerify name list (MatchAny a) = do
-  guard $ notElem a list
+  guard $ Prelude.any (matchParam a) list
   pure $ verifyFailedMessage name list a
 doVerify name list (MatchAll a) = do
-  guard $ Prelude.any (a /=) list
+  guard $ not (all (matchParam a) list)
   pure $ verifyFailedMessage name list a
 
 readAppliedParamsList :: IORef (AppliedRecord params) -> IO (AppliedParamsList params)
@@ -96,23 +93,22 @@ class VerifyCount countType params a where
     ( MockResolvable m
     , ResolvableParams m ~ params
     , HasCallStack
-    , Eq params
     ) =>
     m ->
     countType ->
     a ->
     IO ()
 
-instance VerifyCount CountVerifyMethod (Param a) a where
+instance (ToParam a, Target a ~ a) => VerifyCount CountVerifyMethod (Param a) a where
   shouldApplyTimes v count a = verifyCount v (param a) count
 
-instance VerifyCount Int (Param a) a where
+instance (ToParam a, Target a ~ a) => VerifyCount Int (Param a) a where
   shouldApplyTimes v count a = verifyCount v (param a) (Equal count)
 
-instance {-# OVERLAPPABLE #-} VerifyCount CountVerifyMethod a a where
+instance {-# OVERLAPPABLE #-} (ParamsEq a) => VerifyCount CountVerifyMethod a a where
   shouldApplyTimes v count a = verifyCount v a count
 
-instance {-# OVERLAPPABLE #-} VerifyCount Int a a where
+instance {-# OVERLAPPABLE #-} (ParamsEq a) => VerifyCount Int a a where
   shouldApplyTimes v count a = verifyCount v a (Equal count)
 
 
@@ -125,8 +121,7 @@ compareCount (GreaterThanEqual e) a = a >= e
 compareCount (GreaterThan e) a = a > e
 
 verifyCount ::
-  ( MockResolvable m
-  , Eq (ResolvableParams m)) =>
+  ( MockResolvable m, ParamsEq (ResolvableParams m)) =>
   m ->
   ResolvableParams m ->
   CountVerifyMethod ->
@@ -134,7 +129,7 @@ verifyCount ::
 verifyCount m v method = do
   ResolvedMock mockName (Verifier ref) <- requireResolved m
   appliedParamsList <- readAppliedParamsList ref
-  let appliedCount = length (filter (v ==) appliedParamsList)
+  let appliedCount = length (filter (paramsEq v) appliedParamsList)
   if compareCount method appliedCount
     then pure ()
     else
@@ -171,16 +166,16 @@ class VerifyOrder params input where
   -- As long as the order matches, the verification succeeds.
   shouldApplyInPartialOrder :: (MockResolvable m, ResolvableParams m ~ params, HasCallStack) => m -> [input] -> IO ()
 
-instance (Eq a, Show a) => VerifyOrder (Param a) a where
+instance (ParamsEq a, Show a, ToParam a, Target a ~ a) => VerifyOrder (Param a) a where
   shouldApplyInOrder v a = verifyOrder ExactlySequence v $ param <$> a
   shouldApplyInPartialOrder v a = verifyOrder PartiallySequence v $ param <$> a
 
-instance {-# OVERLAPPABLE #-} (Eq a, Show a) => VerifyOrder a a where
+instance {-# OVERLAPPABLE #-} (ParamsEq a, Show a) => VerifyOrder a a where
   shouldApplyInOrder = verifyOrder ExactlySequence
   shouldApplyInPartialOrder = verifyOrder PartiallySequence
 
 verifyOrder ::
-  (MockResolvable m, Eq (ResolvableParams m), Show (ResolvableParams m)) =>
+  (MockResolvable m, ParamsEq (ResolvableParams m), Show (ResolvableParams m)) =>
   VerifyOrderMethod ->
   m ->
   [ResolvableParams m] ->
@@ -192,7 +187,7 @@ verifyOrder method m matchers = do
   result & maybe (pure ()) (\(VerifyFailed msg) -> errorWithoutStackTrace msg)
 
 doVerifyOrder ::
-  (Eq a, Show a) =>
+  (ParamsEq a, Show a) =>
   VerifyOrderMethod ->
   Maybe MockName ->
   AppliedParamsList a ->
@@ -224,18 +219,22 @@ verifyFailedPartiallySequence name appliedValues expectedValues =
         intercalate "\n" $ ("    " <>) . show <$> appliedValues
       ]
 
-isOrderNotMatched :: Eq a => AppliedParamsList a -> [a] -> Bool
+isOrderNotMatched :: ParamsEq a => AppliedParamsList a -> [a] -> Bool
 isOrderNotMatched appliedValues expectedValues =
   isNothing $
     foldl
       ( \candidates e -> do
           candidates >>= \c -> do
-            index <- elemIndex e c
+            index <- findIndexEq e c
             Just $ drop (index + 1) c
       )
       (Just appliedValues)
       expectedValues
 
+findIndexEq :: ParamsEq a => a -> [a] -> Maybe Int
+findIndexEq _ [] = Nothing
+findIndexEq x (y : ys) = if paramsEq x y then Just 0 else (1 +) <$> findIndexEq x ys
+
 verifyFailedOrderParamCountMismatch :: Maybe MockName -> AppliedParamsList a -> [a] -> VerifyFailed
 verifyFailedOrderParamCountMismatch name appliedValues expectedValues =
   VerifyFailed $
@@ -256,13 +255,13 @@ verifyFailedSequence name fails =
 
 
 
-collectUnExpectedOrder :: Eq a => AppliedParamsList a -> [a] -> [VerifyOrderResult a]
+collectUnExpectedOrder :: ParamsEq a => AppliedParamsList a -> [a] -> [VerifyOrderResult a]
 collectUnExpectedOrder appliedValues expectedValues =
   catMaybes $
     mapWithIndex
       ( \i expectedValue -> do
           let appliedValue = appliedValues !! i
-          guard $ expectedValue /= appliedValue
+          guard $ not (paramsEq expectedValue appliedValue)
           pure VerifyOrderResult {index = i, appliedValue, expectedValue}
       )
       expectedValues
@@ -273,7 +272,7 @@ mapWithIndex f xs = [f i x | (i, x) <- zip [0 ..] xs]
 -- | Verify that the function has been applied to the expected arguments at least the expected number of times.
 shouldApplyTimesGreaterThanEqual ::
   ( VerifyCount CountVerifyMethod params a
-  , Eq params
+  , ParamsEq params
   , MockResolvable m
   , ResolvableParams m ~ params
   , HasCallStack
@@ -287,7 +286,7 @@ shouldApplyTimesGreaterThanEqual m i = shouldApplyTimes m (GreaterThanEqual i)
 -- | Verify that the function is applied to the expected arguments less than or equal to the expected number of times.
 shouldApplyTimesLessThanEqual ::
   ( VerifyCount CountVerifyMethod params a
-  , Eq params
+  , ParamsEq params
   , MockResolvable m
   , ResolvableParams m ~ params
   , HasCallStack
@@ -301,7 +300,7 @@ shouldApplyTimesLessThanEqual m i = shouldApplyTimes m (LessThanEqual i)
 -- | Verify that the function has been applied to the expected arguments a greater number of times than expected.
 shouldApplyTimesGreaterThan ::
   ( VerifyCount CountVerifyMethod params a
-  , Eq params
+  , ParamsEq params
   , MockResolvable m
   , ResolvableParams m ~ params
   , HasCallStack
@@ -315,7 +314,7 @@ shouldApplyTimesGreaterThan m i = shouldApplyTimes m (GreaterThan i)
 -- | Verify that the function has been applied to the expected arguments less than the expected number of times.
 shouldApplyTimesLessThan ::
   ( VerifyCount CountVerifyMethod params a
-  , Eq params
+  , ParamsEq params
   , MockResolvable m
   , ResolvableParams m ~ params
   , HasCallStack
