diff --git a/diff.patch b/diff.patch
index 8aa42e7..e69de29 100644
--- a/diff.patch
+++ b/diff.patch
@@ -1,831 +0,0 @@
-diff --git a/diff.patch b/diff.patch
-index 96c969e..e69de29 100644
---- a/diff.patch
-+++ b/diff.patch
-@@ -1,207 +0,0 @@
--diff --git a/src/Test/MockCat/Internal/Builder.hs b/src/Test/MockCat/Internal/Builder.hs
--index e0b905f..4709b36 100644
----- a/src/Test/MockCat/Internal/Builder.hs
--+++ b/src/Test/MockCat/Internal/Builder.hs
--@@ -69,11 +69,11 @@ type family CurriedFn (mode :: k) (args :: Type) (r :: Type) :: Type where
-- class ModeSpec mode => BuildCurriedGeneric mode args r fn | mode args r -> fn where
--   buildGeneric :: InputFn mode args r -> fn
-- 
---instance (ModeSpec mode, fn ~ (a -> ApplyMode mode r))
--+instance (ModeSpec mode, fn ~ (a -> ApplyMode mode r), ToParam a, Target a ~ a, Eq a)
--       => BuildCurriedGeneric mode (Param a) r fn where
---  buildGeneric f a = finalize @mode @r (f (param a))
--+  buildGeneric f = \a -> finalize @mode @r (f (param a))
-- 
---instance (ModeSpec mode, BuildCurriedGeneric mode rest r fn, fn' ~ (a -> fn))
--+instance (ModeSpec mode, BuildCurriedGeneric mode rest r fn, fn' ~ (a -> fn), ToParam a, Target a ~ a, Eq a)
--       => BuildCurriedGeneric mode (Param a :> rest) r fn' where
--   buildGeneric input a = buildGeneric @mode @rest @r (input . (\rest -> p a :> rest))
-- -- ------------
--@@ -248,7 +248,7 @@ incrementCount key list =
-- runCase :: Cases a b -> [a]
-- runCase (Cases s) = execState s []
-- 
---p :: a -> Param a
--+p :: (ToParam a, Target a ~ a) => a -> Param a
-- p = param
-- 
-- class StubBuilder params fn | params -> fn where
--diff --git a/src/Test/MockCat/Mock.hs b/src/Test/MockCat/Mock.hs
--index 6b4dc47..3d8f6de 100644
----- a/src/Test/MockCat/Mock.hs
--+++ b/src/Test/MockCat/Mock.hs
--@@ -100,6 +100,9 @@ createConstantStubFn ::
--   ( MonadIO m
--   , MockBuilder (Param b) b ()
--   , Typeable b
--+  , ToParam b
--+  , Target b ~ b
--+  , Eq b
--   ) =>
--   b ->
--   m b
--@@ -110,6 +113,9 @@ createNamedConstantStubFn ::
--   ( MonadIO m
--   , MockBuilder (Param b) b ()
--   , Typeable b
--+  , ToParam b
--+  , Target b ~ b
--+  , Eq b
--   ) =>
--   MockName ->
--   b ->
--diff --git a/src/Test/MockCat/Param.hs b/src/Test/MockCat/Param.hs
--index 7258594..7f83d91 100644
----- a/src/Test/MockCat/Param.hs
--+++ b/src/Test/MockCat/Param.hs
--@@ -7,6 +7,10 @@
-- {-# LANGUAGE TypeFamilyDependencies #-}
-- {-# LANGUAGE TypeOperators #-}
-- {-# LANGUAGE UndecidableInstances #-}
--+{-# LANGUAGE GADTs #-}
--+{-# LANGUAGE MagicHash #-}
--+{-# LANGUAGE TypeFamilies #-}
--+
-- {-# OPTIONS_GHC -Wno-redundant-constraints #-}
-- 
-- -- | This module is a parameter of the mock function.
--@@ -26,23 +30,54 @@ module Test.MockCat.Param
--     ReturnOf,
--     ProjectionReturn,
--     projReturn,
---    returnValue
--+    returnValue,
--+    ToParam(..),
--+    Target,
--   )
-- where
-- 
-- import Test.MockCat.Cons ((:>) (..))
-- import Unsafe.Coerce (unsafeCoerce)
-- import Prelude hiding (any)
--+import GHC.Exts ( reallyUnsafePtrEquality#, Int(I#) )
--+
--+data Param v where
--+  ExpectValue :: Eq v => v -> Param v
--+  ExpectCondition :: (v -> Bool) -> String -> Param v
--+  ExpectRef :: v -> Param v
--+
--+matchParam :: Param v -> v -> Bool
--+matchParam (ExpectValue a) b = a == b
--+matchParam (ExpectCondition f _) a = f a
--+matchParam (ExpectRef e) a = pointerEq e a
--+
--+pointerEq :: a -> a -> Bool
--+pointerEq a b = I# (reallyUnsafePtrEquality# (unsafeCoerce a) (unsafeCoerce b)) == 1
--+
--+type family Target a where
--+  Target (Param a) = a
--+  Target (a -> b) = a -> b
--+  Target a = a
--+
--+class ToParam a where
--+  toParam :: a -> Param (Target a)
--+
--+instance {-# OVERLAPPING #-} ToParam (Param a) where
--+  toParam = id
--+
--+instance {-# OVERLAPPING #-} ToParam (a -> b) where
--+  toParam = ExpectRef
--+
--+instance {-# OVERLAPPABLE #-} (Eq a, Target a ~ a) => ToParam a where
--+  toParam = ExpectValue
--+
-- 
---data Param v
---  = ExpectValue v
---  | ExpectCondition (v -> Bool) String
-- 
---instance (Eq a) => Eq (Param a) where
---  (ExpectValue a) == (ExpectValue b) = a == b
---  (ExpectValue a) == (ExpectCondition m2 _) = m2 a
---  (ExpectCondition m1 _) == (ExpectValue b) = m1 b
---  (ExpectCondition _ l1) == (ExpectCondition _ l2) = l1 == l2
--+-- instance (Eq a) => Eq (Param a) where
--+--   (ExpectValue a) == (ExpectValue b) = a == b
--+--   (ExpectValue a) == (ExpectCondition m2 _) = m2 a
--+--   (ExpectCondition m1 _) == (ExpectValue b) = m1 b
--+--   (ExpectCondition _ l1) == (ExpectCondition _ l2) = l1 == l2
-- 
-- type family ShowResult a where
--   ShowResult String = String
--@@ -66,23 +101,23 @@ value :: Param v -> v
-- value (ExpectValue a) = a
-- value _ = error "not implement"
-- 
---param :: v -> Param v
---param = ExpectValue
--+param :: (ToParam v, Target v ~ v) => v -> Param v
--+param = toParam
-- 
-- class ConsGen a b r | a b -> r where
--   (|>) :: a -> b -> r
-- 
---instance {-# OVERLAPPING #-} (Param a ~ a', (Param b :> c) ~ bc) => ConsGen a (Param b :> c) (a' :> bc) where
--+instance {-# OVERLAPPING #-} (Param a ~ a', (Param b :> c) ~ bc, ToParam a, Target a ~ a, Eq a) => ConsGen a (Param b :> c) (a' :> bc) where
--   (|>) a = (:>) (param a)
-- instance {-# OVERLAPPING #-} ((Param b :> c) ~ bc) => ConsGen (Param a) (Param b :> c) (Param a :> bc) where
--   (|>) = (:>)
-- instance ConsGen (Param a) (Param b) (Param a :> Param b) where
--   (|>) = (:>)
---instance {-# OVERLAPPABLE #-} ((Param b) ~ b') => ConsGen (Param a) b (Param a :> b') where
--+instance {-# OVERLAPPABLE #-} ((Param b) ~ b', ToParam b, Target b ~ b, Eq b) => ConsGen (Param a) b (Param a :> b') where
--   (|>) a b = (:>) a (param b)
---instance {-# OVERLAPPABLE #-} ((Param a) ~ a') => ConsGen a (Param b) (a' :> Param b) where
--+instance {-# OVERLAPPABLE #-} ((Param a) ~ a', ToParam a, Target a ~ a, Eq a) => ConsGen a (Param b) (a' :> Param b) where
--   (|>) a = (:>) (param a)
---instance {-# OVERLAPPABLE #-} (Param a ~ a', Param b ~ b') => ConsGen a b (a' :> b') where
--+instance {-# OVERLAPPABLE #-} (Param a ~ a', Param b ~ b', ToParam a, Target a ~ a, Eq a, ToParam b, Target b ~ b, Eq b) => ConsGen a b (a' :> b') where
--   (|>) a b = (:>) (param a) (param b)
-- 
-- infixr 8 |>
--diff --git a/src/Test/MockCat/Verify.hs b/src/Test/MockCat/Verify.hs
--index ae1ba98..b201c73 100644
----- a/src/Test/MockCat/Verify.hs
--+++ b/src/Test/MockCat/Verify.hs
--@@ -13,6 +13,7 @@
-- {-# LANGUAGE DataKinds #-}
-- {-# LANGUAGE MultiParamTypeClasses #-}
-- {-# OPTIONS_GHC -Wno-redundant-constraints #-}
--+{-# LANGUAGE InstanceSigs #-}
-- module Test.MockCat.Verify where
-- 
-- import Test.MockCat.Internal.Types
--@@ -45,7 +46,7 @@ class Verify params input where
--     input ->
--     IO ()
-- 
---instance (Eq a, Show a) => Verify (Param a) a where
--+instance (Eq a, Show a, ToParam a, Target a ~ a, Eq (Param a)) => Verify (Param a) a where
--   shouldApplyTo v a = verify v (MatchAny (param a))
-- 
-- instance (Eq a, Show a) => Verify a a where
--@@ -103,10 +104,13 @@ class VerifyCount countType params a where
--     a ->
--     IO ()
-- 
---instance VerifyCount CountVerifyMethod (Param a) a where
--+instance (ToParam a, Target a ~ a, Eq a) => VerifyCount CountVerifyMethod (Param a) a where
--   shouldApplyTimes v count a = verifyCount v (param a) count
-- 
---instance VerifyCount Int (Param a) a where
--+instance (ToParam a, Target a ~ a, Eq a) => VerifyCount Int (Param a) a where
--+  shouldApplyTimes :: (MockResolvable m, ResolvableParams m ~ Param a, HasCallStack,
--+    Eq (Param a)) =>
--+    m -> Int -> a -> IO ()
--   shouldApplyTimes v count a = verifyCount v (param a) (Equal count)
-- 
-- instance {-# OVERLAPPABLE #-} VerifyCount CountVerifyMethod a a where
--@@ -171,7 +175,7 @@ class VerifyOrder params input where
--   -- As long as the order matches, the verification succeeds.
--   shouldApplyInPartialOrder :: (MockResolvable m, ResolvableParams m ~ params, HasCallStack) => m -> [input] -> IO ()
-- 
---instance (Eq a, Show a) => VerifyOrder (Param a) a where
--+instance (Eq a, Show a, ToParam a, Target a ~ a, Eq (Param a)) => VerifyOrder (Param a) a where
--   shouldApplyInOrder v a = verifyOrder ExactlySequence v $ param <$> a
--   shouldApplyInPartialOrder v a = verifyOrder PartiallySequence v $ param <$> a
-- 
-diff --git a/src/Test/MockCat/AssociationList.hs b/src/Test/MockCat/AssociationList.hs
-index 3f057c3..bc8c467 100644
---- a/src/Test/MockCat/AssociationList.hs
-+++ b/src/Test/MockCat/AssociationList.hs
-@@ -1,33 +1,34 @@
- module Test.MockCat.AssociationList 
-- (AssociationList, empty, insert, lookup, member, (!?), update) where
-+(AssociationList, empty, insert, lookup, member, (!?), update) where
- 
- import Prelude hiding (lookup)
- import Data.Maybe (isJust)
-+import Test.MockCat.Param (ParamsEq, paramsEq)
- 
- type AssociationList k a = [(k, a)]
- 
- empty :: AssociationList k a
- empty = []
- 
--insert :: Eq k => k -> a -> AssociationList k a -> AssociationList k a
-+insert :: ParamsEq k => k -> a -> AssociationList k a -> AssociationList k a
- insert key value [] = [(key, value)]
- insert key value ((k, v) : xs)
--  | key == k  = (key, value) : xs
-+  | paramsEq key k  = (key, value) : xs
-   | otherwise = (k, v) : insert key value xs
- 
--lookup :: Eq k => k -> AssociationList k a -> Maybe a
-+lookup :: ParamsEq k => k -> AssociationList k a -> Maybe a
- lookup _ [] = Nothing
- lookup key ((k, a) : xs)
--  | key == k  = Just a
-+  | paramsEq key k  = Just a
-   | otherwise = lookup key xs
- 
--member :: Eq k => k -> AssociationList k a -> Bool
-+member :: ParamsEq k => k -> AssociationList k a -> Bool
- member k list = isJust (lookup k list)
- 
--(!?) :: Eq k => AssociationList k a -> k -> Maybe a
-+(!?) :: ParamsEq k => AssociationList k a -> k -> Maybe a
- (!?) = flip lookup
- 
--update :: Eq k => (a -> a) -> k -> AssociationList k a -> AssociationList k a
-+update :: ParamsEq k => (a -> a) -> k -> AssociationList k a -> AssociationList k a
- update f key list =
-   case list !? key of
-     Just value -> insert key (f value) list
-diff --git a/src/Test/MockCat/Internal/Builder.hs b/src/Test/MockCat/Internal/Builder.hs
-index e0b905f..c594e12 100644
---- a/src/Test/MockCat/Internal/Builder.hs
-+++ b/src/Test/MockCat/Internal/Builder.hs
-@@ -69,11 +69,11 @@ type family CurriedFn (mode :: k) (args :: Type) (r :: Type) :: Type where
- class ModeSpec mode => BuildCurriedGeneric mode args r fn | mode args r -> fn where
-   buildGeneric :: InputFn mode args r -> fn
- 
--instance (ModeSpec mode, fn ~ (a -> ApplyMode mode r))
-+instance (ModeSpec mode, fn ~ (a -> ApplyMode mode r), ToParam a, Target a ~ a)
-       => BuildCurriedGeneric mode (Param a) r fn where
--  buildGeneric f a = finalize @mode @r (f (param a))
-+  buildGeneric f = \a -> finalize @mode @r (f (param a))
- 
--instance (ModeSpec mode, BuildCurriedGeneric mode rest r fn, fn' ~ (a -> fn))
-+instance (ModeSpec mode, BuildCurriedGeneric mode rest r fn, fn' ~ (a -> fn), ToParam a, Target a ~ a)
-       => BuildCurriedGeneric mode (Param a :> rest) r fn' where
-   buildGeneric input a = buildGeneric @mode @rest @r (input . (\rest -> p a :> rest))
- -- ------------
-@@ -225,13 +225,13 @@ appendAppliedParams ref inputParams = do
-         }
-     in (newRecord, ()))
- 
--readAppliedCount :: Eq params => IORef (AppliedRecord params) -> params -> IO Int
-+readAppliedCount :: ParamsEq params => IORef (AppliedRecord params) -> params -> IO Int
- readAppliedCount ref params = do
-   record <- readIORef ref
-   let count = appliedParamsCounter record
-   pure $ fromMaybe 0 (lookup params count)
- 
--incrementAppliedParamCount :: Eq params => IORef (AppliedRecord params) -> params -> IO ()
-+incrementAppliedParamCount :: ParamsEq params => IORef (AppliedRecord params) -> params -> IO ()
- incrementAppliedParamCount ref inputParams = do
-   atomicModifyIORef' ref (\AppliedRecord {appliedParamsList, appliedParamsCounter} ->
-     let newRecord = AppliedRecord {
-@@ -240,7 +240,7 @@ incrementAppliedParamCount ref inputParams = do
-         }
-     in (newRecord, ()))
- 
--incrementCount :: Eq k => k -> AppliedParamsCounter k -> AppliedParamsCounter k
-+incrementCount :: ParamsEq k => k -> AppliedParamsCounter k -> AppliedParamsCounter k
- incrementCount key list =
-   if member key list then update (+ 1) key list
-   else insert key 1 list
-@@ -248,7 +248,7 @@ incrementCount key list =
- runCase :: Cases a b -> [a]
- runCase (Cases s) = execState s []
- 
--p :: a -> Param a
-+p :: (ToParam a, Target a ~ a) => a -> Param a
- p = param
- 
- class StubBuilder params fn | params -> fn where
-@@ -301,7 +301,7 @@ type ParamConstraints params args r =
-   , ProjectionReturn params
-   , ArgsOf params ~ args
-   , ReturnOf params ~ Param r
--  , Eq args
-+  , ParamsEq args
-   , Show args
-   )
- 
-@@ -309,13 +309,13 @@ extractReturnValue :: ParamConstraints params args r => Maybe MockName -> params
- extractReturnValue name params inputParams = do
-   validateOnly name (projArgs params) inputParams `seq` returnValue params
- 
--validateOnly :: (Eq a, Show a) => Maybe MockName -> a -> a -> ()
-+validateOnly :: (ParamsEq a, Show a) => Maybe MockName -> a -> a -> ()
- validateOnly name expected actual = do
-   validateParamsPure name expected actual
- 
--validateParamsPure :: (Eq a, Show a) => Maybe MockName -> a -> a -> ()
-+validateParamsPure :: (ParamsEq a, Show a) => Maybe MockName -> a -> a -> ()
- validateParamsPure name expected actual =
--  if expected == actual
-+  if paramsEq expected actual
-     then ()
-     else errorWithoutStackTrace $ message name expected actual
- 
-@@ -339,7 +339,7 @@ findReturnValuePure ::
-   args ->
-   Maybe r
- findReturnValuePure paramsList inputParams = do
--  let matchedParams = filter (\params -> projArgs params == inputParams) paramsList
-+  let matchedParams = filter (\params -> projArgs params `paramsEq` inputParams) paramsList
-   case matchedParams of
-     [] -> Nothing
-     _ -> do
-@@ -363,7 +363,7 @@ singleInvocationStep ::
-   InvocationStep args r
- singleInvocationStep name params inputParams record@AppliedRecord {appliedParamsList, appliedParamsCounter} = do
-   let expected = projArgs params
--  if expected == inputParams
-+  if expected `paramsEq` inputParams
-     then
-       (AppliedRecord {
-         appliedParamsList = appliedParamsList ++ [inputParams]
-@@ -379,7 +379,7 @@ casesInvocationStep ::
-   InvocationStep args r
- casesInvocationStep name paramsList inputParams AppliedRecord {appliedParamsList, appliedParamsCounter} = do
-   let newAppliedList = appliedParamsList ++ [inputParams]
--      matchedParams = filter (\params -> projArgs params == inputParams) paramsList
-+      matchedParams = filter (\params -> projArgs params `paramsEq` inputParams) paramsList
-       expectedArgs = projArgs <$> paramsList
-    in case matchedParams of
-         [] ->
-diff --git a/src/Test/MockCat/Internal/Message.hs b/src/Test/MockCat/Internal/Message.hs
-index 9bfc7f9..77b42fc 100644
---- a/src/Test/MockCat/Internal/Message.hs
-+++ b/src/Test/MockCat/Internal/Message.hs
-@@ -6,6 +6,7 @@ import Data.List (intercalate)
- import Data.Char (isLower)
- import Data.Text (pack, replace, unpack)
- import Test.MockCat.Internal.Types
-+import Test.MockCat.Param (Param)
- 
- message :: Show a => Maybe MockName -> a -> a -> String
- message name expected actual =
-@@ -41,7 +42,7 @@ quoteToken s
-   | not (null s) && isLower (head s) = '"' : s ++ "\""
-   | otherwise = s
- 
--verifyFailedMessage :: Show a => Maybe MockName -> AppliedParamsList a -> a -> VerifyFailed
-+verifyFailedMessage :: Show a => Maybe MockName -> AppliedParamsList a -> Param a -> VerifyFailed
- verifyFailedMessage name appliedParams expected =
-   VerifyFailed $
-     intercalate
-diff --git a/src/Test/MockCat/Internal/Types.hs b/src/Test/MockCat/Internal/Types.hs
-index 2a8e0ea..4b284cd 100644
---- a/src/Test/MockCat/Internal/Types.hs
-+++ b/src/Test/MockCat/Internal/Types.hs
-@@ -15,9 +15,10 @@ import Control.Monad (ap)
- import Data.IORef (IORef)
- import Data.Maybe
- import GHC.IO (unsafePerformIO)
--import Test.MockCat.AssociationList (AssociationList)
-+import Test.MockCat.AssociationList (AssociationList, lookup)
- import Prelude hiding (lookup)
- import Control.Monad.State ( State )
-+import Test.MockCat.Param (Param, ParamsEq, paramsEq)
- 
- newtype Verifier params = Verifier (IORef (AppliedRecord params))
- 
-@@ -28,7 +29,20 @@ data AppliedRecord params = AppliedRecord {
-   appliedParamsList :: AppliedParamsList params,
-   appliedParamsCounter :: AppliedParamsCounter params
- }
--  deriving (Eq, Show)
-+  deriving (Show)
-+
-+instance ParamsEq params => Eq (AppliedRecord params) where
-+  (AppliedRecord l1 c1) == (AppliedRecord l2 c2) =
-+    listsEqual && countersEqual
-+    where
-+      listsEqual = length l1 == length l2 && and (zipWith paramsEq l1 l2)
-+      countersEqual =
-+        length c1 == length c2
-+          && all
-+            (\(k, v) -> case lookup k c2 of
-+                Just v2 -> v == v2
-+                Nothing -> False)
-+            c1
- 
- data CountVerifyMethod
-   = Equal Int
-@@ -74,7 +88,7 @@ data VerifyOrderResult a = VerifyOrderResult
- type Message = String
- 
- -- verify
--data VerifyMatchType a = MatchAny a | MatchAll a
-+data VerifyMatchType a = MatchAny (Param a) | MatchAll (Param a)
- 
- type MockName = String
- 
-diff --git a/src/Test/MockCat/Mock.hs b/src/Test/MockCat/Mock.hs
-index 6b4dc47..3d8f6de 100644
---- a/src/Test/MockCat/Mock.hs
-+++ b/src/Test/MockCat/Mock.hs
-@@ -100,6 +100,9 @@ createConstantStubFn ::
-   ( MonadIO m
-   , MockBuilder (Param b) b ()
-   , Typeable b
-+  , ToParam b
-+  , Target b ~ b
-+  , Eq b
-   ) =>
-   b ->
-   m b
-@@ -110,6 +113,9 @@ createNamedConstantStubFn ::
-   ( MonadIO m
-   , MockBuilder (Param b) b ()
-   , Typeable b
-+  , ToParam b
-+  , Target b ~ b
-+  , Eq b
-   ) =>
-   MockName ->
-   b ->
-diff --git a/src/Test/MockCat/Param.hs b/src/Test/MockCat/Param.hs
-index 7258594..6f303b1 100644
---- a/src/Test/MockCat/Param.hs
-+++ b/src/Test/MockCat/Param.hs
-@@ -7,6 +7,10 @@
- {-# LANGUAGE TypeFamilyDependencies #-}
- {-# LANGUAGE TypeOperators #-}
- {-# LANGUAGE UndecidableInstances #-}
-+{-# LANGUAGE GADTs #-}
-+{-# LANGUAGE MagicHash #-}
-+{-# LANGUAGE TypeFamilies #-}
-+
- {-# OPTIONS_GHC -Wno-redundant-constraints #-}
- 
- -- | This module is a parameter of the mock function.
-@@ -26,23 +30,70 @@ module Test.MockCat.Param
-     ReturnOf,
-     ProjectionReturn,
-     projReturn,
--    returnValue
-+    returnValue,
-+    ToParam(..),
-+    Target,
-+    matchParam,
-+    ParamsEq(..),
-   )
- where
- 
- import Test.MockCat.Cons ((:>) (..))
- import Unsafe.Coerce (unsafeCoerce)
- import Prelude hiding (any)
-+import GHC.Exts ( reallyUnsafePtrEquality#, Int(I#) )
-+import Control.Monad.Trans.State (StateT)
-+
-+data Param v where
-+  ExpectValue :: Eq v => v -> Param v
-+  ExpectCondition :: (v -> Bool) -> String -> Param v
-+  ExpectRef :: v -> Param v
-+
-+matchParam :: Param v -> v -> Bool
-+matchParam (ExpectValue a) b = a == b
-+matchParam (ExpectCondition f _) a = f a
-+matchParam (ExpectRef e) a = pointerEq e a
-+
-+pointerEq :: a -> a -> Bool
-+pointerEq a b = I# (reallyUnsafePtrEquality# (unsafeCoerce a) (unsafeCoerce b)) == 1
-+
-+type family Target a where
-+  Target (Param a) = a
-+  Target (a -> b) = a -> b
-+  Target a = a
-+
-+class ToParam a where
-+  toParam :: a -> Param (Target a)
-+
-+instance {-# OVERLAPPING #-} ToParam (Param a) where
-+  toParam = id
-+
-+instance {-# OVERLAPPING #-} ToParam (a -> b) where
-+  toParam = ExpectRef
-+
-+instance {-# OVERLAPPING #-} ToParam (IO a) where
-+  toParam = ExpectRef
-+
-+instance {-# OVERLAPPING #-} ToParam (StateT s m a) where
-+  toParam = ExpectRef
-+
-+instance {-# OVERLAPPABLE #-} (Target a ~ a, Eq a) => ToParam a where
-+  toParam = ExpectValue
-+
- 
--data Param v
--  = ExpectValue v
--  | ExpectCondition (v -> Bool) String
- 
--instance (Eq a) => Eq (Param a) where
-+-- instance (Eq a) => Eq (Param a) where
-+--   (ExpectValue a) == (ExpectValue b) = a == b
-+--   (ExpectValue a) == (ExpectCondition m2 _) = m2 a
-+--   (ExpectCondition m1 _) == (ExpectValue b) = m1 b
-+--   (ExpectCondition _ l1) == (ExpectCondition _ l2) = l1 == l2
-+instance Eq (Param a) where
-   (ExpectValue a) == (ExpectValue b) = a == b
-   (ExpectValue a) == (ExpectCondition m2 _) = m2 a
-   (ExpectCondition m1 _) == (ExpectValue b) = m1 b
-   (ExpectCondition _ l1) == (ExpectCondition _ l2) = l1 == l2
-+  (ExpectRef r) == (ExpectRef s) = pointerEq r s
-+  _ == _ = False
- 
- type family ShowResult a where
-   ShowResult String = String
-@@ -66,23 +117,23 @@ value :: Param v -> v
- value (ExpectValue a) = a
- value _ = error "not implement"
- 
--param :: v -> Param v
--param = ExpectValue
-+param :: (ToParam v, Target v ~ v) => v -> Param v
-+param = toParam
- 
- class ConsGen a b r | a b -> r where
-   (|>) :: a -> b -> r
- 
--instance {-# OVERLAPPING #-} (Param a ~ a', (Param b :> c) ~ bc) => ConsGen a (Param b :> c) (a' :> bc) where
-+instance {-# OVERLAPPING #-} (Param a ~ a', (Param b :> c) ~ bc, ToParam a, Target a ~ a) => ConsGen a (Param b :> c) (a' :> bc) where
-   (|>) a = (:>) (param a)
- instance {-# OVERLAPPING #-} ((Param b :> c) ~ bc) => ConsGen (Param a) (Param b :> c) (Param a :> bc) where
-   (|>) = (:>)
- instance ConsGen (Param a) (Param b) (Param a :> Param b) where
-   (|>) = (:>)
--instance {-# OVERLAPPABLE #-} ((Param b) ~ b') => ConsGen (Param a) b (Param a :> b') where
-+instance {-# OVERLAPPABLE #-} ((Param b) ~ b', ToParam b, Target b ~ b) => ConsGen (Param a) b (Param a :> b') where
-   (|>) a b = (:>) a (param b)
--instance {-# OVERLAPPABLE #-} ((Param a) ~ a') => ConsGen a (Param b) (a' :> Param b) where
-+instance {-# OVERLAPPABLE #-} ((Param a) ~ a', ToParam a, Target a ~ a) => ConsGen a (Param b) (a' :> Param b) where
-   (|>) a = (:>) (param a)
--instance {-# OVERLAPPABLE #-} (Param a ~ a', Param b ~ b') => ConsGen a b (a' :> b') where
-+instance {-# OVERLAPPABLE #-} (Param a ~ a', Param b ~ b', ToParam a, Target a ~ a, ToParam b, Target b ~ b) => ConsGen a b (a' :> b') where
-   (|>) a b = (:>) (param a) (param b)
- 
- infixr 8 |>
-@@ -145,4 +196,43 @@ instance
-   projReturn (_ :> rest) = projReturn rest
- 
- returnValue :: (ProjectionReturn params, ReturnOf params ~ Param r) => params -> r
--returnValue = value . projReturn
-\ No newline at end of file
-+returnValue = value . projReturn
-+
-+
-+-- | Class for equality-like comparison of recorded parameters.
-+--   Instances implement matching semantics: for `Param` types use `matchParam`,
-+--   for composed `(:>)` compare components recursively, and for `()` always true.
-+class ParamsEq a where
-+  paramsEq :: a -> a -> Bool
-+
-+instance ParamsEq () where
-+  paramsEq () () = True
-+
-+-- extract underlying value if available (ExpectValue / ExpectRef)
-+unParamValue :: Param v -> Maybe v
-+unParamValue (ExpectValue v) = Just v
-+unParamValue (ExpectRef v) = Just v
-+unParamValue (ExpectCondition _ _) = Nothing
-+
-+instance {-# OVERLAPPING #-} ParamsEq (Param a) where
-+  paramsEq expected actual =
-+    case expected of
-+      ExpectCondition f _ ->
-+        case unParamValue actual of
-+          Just v -> f v
-+          Nothing -> False
-+      ExpectValue v ->
-+        case unParamValue actual of
-+          Just a -> v == a
-+          Nothing -> False
-+      ExpectRef r ->
-+        case unParamValue actual of
-+          Just a -> pointerEq r a
-+          Nothing -> False
-+
-+instance {-# OVERLAPPING #-} (ParamsEq a, ParamsEq b) => ParamsEq (a :> b) where
-+  paramsEq (x :> xs) (y :> ys) = paramsEq x y && paramsEq xs ys
-+
-+-- Fallback for types that have Eq (non-Param types)
-+instance {-# INCOHERENT #-} Eq a => ParamsEq a where
-+  paramsEq = (==)
-\ No newline at end of file
-diff --git a/src/Test/MockCat/Verify.hs b/src/Test/MockCat/Verify.hs
-index ae1ba98..00e972a 100644
---- a/src/Test/MockCat/Verify.hs
-+++ b/src/Test/MockCat/Verify.hs
-@@ -13,13 +13,14 @@
- {-# LANGUAGE DataKinds #-}
- {-# LANGUAGE MultiParamTypeClasses #-}
- {-# OPTIONS_GHC -Wno-redundant-constraints #-}
-+{-# LANGUAGE InstanceSigs #-}
- module Test.MockCat.Verify where
- 
- import Test.MockCat.Internal.Types
- import Control.Monad (guard, when)
- import Data.Function ((&))
- import Data.IORef (IORef, readIORef)
--import Data.List (elemIndex, intercalate)
-+import Data.List (intercalate)
- import Data.Maybe
- import Test.MockCat.Param
- import Prelude hiding (lookup)
-@@ -45,15 +46,11 @@ class Verify params input where
-     input ->
-     IO ()
- 
--instance (Eq a, Show a) => Verify (Param a) a where
-+instance (Show a, ToParam a, Target a ~ a) => Verify a a where
-   shouldApplyTo v a = verify v (MatchAny (param a))
- 
--instance (Eq a, Show a) => Verify a a where
--  shouldApplyTo v a = verify v (MatchAny a)
--
- verify ::
-   ( MockResolvable m
--  , Eq (ResolvableParams m)
-   , Show (ResolvableParams m)
-   ) =>
-   m ->
-@@ -65,12 +62,12 @@ verify m matchType = do
-   let result = doVerify mockName appliedParamsList matchType
-   result & maybe (pure ()) (\(VerifyFailed msg) -> errorWithoutStackTrace msg)
- 
--doVerify :: (Eq a, Show a) => Maybe MockName -> AppliedParamsList a -> VerifyMatchType a -> Maybe VerifyFailed
-+doVerify :: (Show a) => Maybe MockName -> AppliedParamsList a -> VerifyMatchType a -> Maybe VerifyFailed
- doVerify name list (MatchAny a) = do
--  guard $ notElem a list
-+  guard $ Prelude.any (matchParam a) list
-   pure $ verifyFailedMessage name list a
- doVerify name list (MatchAll a) = do
--  guard $ Prelude.any (a /=) list
-+  guard $ not (all (matchParam a) list)
-   pure $ verifyFailedMessage name list a
- 
- readAppliedParamsList :: IORef (AppliedRecord params) -> IO (AppliedParamsList params)
-@@ -96,23 +93,22 @@ class VerifyCount countType params a where
-     ( MockResolvable m
-     , ResolvableParams m ~ params
-     , HasCallStack
--    , Eq params
-     ) =>
-     m ->
-     countType ->
-     a ->
-     IO ()
- 
--instance VerifyCount CountVerifyMethod (Param a) a where
-+instance (ToParam a, Target a ~ a) => VerifyCount CountVerifyMethod (Param a) a where
-   shouldApplyTimes v count a = verifyCount v (param a) count
- 
--instance VerifyCount Int (Param a) a where
-+instance (ToParam a, Target a ~ a) => VerifyCount Int (Param a) a where
-   shouldApplyTimes v count a = verifyCount v (param a) (Equal count)
- 
--instance {-# OVERLAPPABLE #-} VerifyCount CountVerifyMethod a a where
-+instance {-# OVERLAPPABLE #-} (ParamsEq a) => VerifyCount CountVerifyMethod a a where
-   shouldApplyTimes v count a = verifyCount v a count
- 
--instance {-# OVERLAPPABLE #-} VerifyCount Int a a where
-+instance {-# OVERLAPPABLE #-} (ParamsEq a) => VerifyCount Int a a where
-   shouldApplyTimes v count a = verifyCount v a (Equal count)
- 
- 
-@@ -125,8 +121,7 @@ compareCount (GreaterThanEqual e) a = a >= e
- compareCount (GreaterThan e) a = a > e
- 
- verifyCount ::
--  ( MockResolvable m
--  , Eq (ResolvableParams m)) =>
-+  ( MockResolvable m, ParamsEq (ResolvableParams m)) =>
-   m ->
-   ResolvableParams m ->
-   CountVerifyMethod ->
-@@ -134,7 +129,7 @@ verifyCount ::
- verifyCount m v method = do
-   ResolvedMock mockName (Verifier ref) <- requireResolved m
-   appliedParamsList <- readAppliedParamsList ref
--  let appliedCount = length (filter (v ==) appliedParamsList)
-+  let appliedCount = length (filter (paramsEq v) appliedParamsList)
-   if compareCount method appliedCount
-     then pure ()
-     else
-@@ -171,16 +166,16 @@ class VerifyOrder params input where
-   -- As long as the order matches, the verification succeeds.
-   shouldApplyInPartialOrder :: (MockResolvable m, ResolvableParams m ~ params, HasCallStack) => m -> [input] -> IO ()
- 
--instance (Eq a, Show a) => VerifyOrder (Param a) a where
-+instance (ParamsEq a, Show a, ToParam a, Target a ~ a) => VerifyOrder (Param a) a where
-   shouldApplyInOrder v a = verifyOrder ExactlySequence v $ param <$> a
-   shouldApplyInPartialOrder v a = verifyOrder PartiallySequence v $ param <$> a
- 
--instance {-# OVERLAPPABLE #-} (Eq a, Show a) => VerifyOrder a a where
-+instance {-# OVERLAPPABLE #-} (ParamsEq a, Show a) => VerifyOrder a a where
-   shouldApplyInOrder = verifyOrder ExactlySequence
-   shouldApplyInPartialOrder = verifyOrder PartiallySequence
- 
- verifyOrder ::
--  (MockResolvable m, Eq (ResolvableParams m), Show (ResolvableParams m)) =>
-+  (MockResolvable m, ParamsEq (ResolvableParams m), Show (ResolvableParams m)) =>
-   VerifyOrderMethod ->
-   m ->
-   [ResolvableParams m] ->
-@@ -192,7 +187,7 @@ verifyOrder method m matchers = do
-   result & maybe (pure ()) (\(VerifyFailed msg) -> errorWithoutStackTrace msg)
- 
- doVerifyOrder ::
--  (Eq a, Show a) =>
-+  (ParamsEq a, Show a) =>
-   VerifyOrderMethod ->
-   Maybe MockName ->
-   AppliedParamsList a ->
-@@ -224,18 +219,22 @@ verifyFailedPartiallySequence name appliedValues expectedValues =
-         intercalate "\n" $ ("    " <>) . show <$> appliedValues
-       ]
- 
--isOrderNotMatched :: Eq a => AppliedParamsList a -> [a] -> Bool
-+isOrderNotMatched :: ParamsEq a => AppliedParamsList a -> [a] -> Bool
- isOrderNotMatched appliedValues expectedValues =
-   isNothing $
-     foldl
-       ( \candidates e -> do
-           candidates >>= \c -> do
--            index <- elemIndex e c
-+            index <- findIndexEq e c
-             Just $ drop (index + 1) c
-       )
-       (Just appliedValues)
-       expectedValues
- 
-+findIndexEq :: ParamsEq a => a -> [a] -> Maybe Int
-+findIndexEq _ [] = Nothing
-+findIndexEq x (y : ys) = if paramsEq x y then Just 0 else (1 +) <$> findIndexEq x ys
-+
- verifyFailedOrderParamCountMismatch :: Maybe MockName -> AppliedParamsList a -> [a] -> VerifyFailed
- verifyFailedOrderParamCountMismatch name appliedValues expectedValues =
-   VerifyFailed $
-@@ -256,13 +255,13 @@ verifyFailedSequence name fails =
- 
- 
- 
--collectUnExpectedOrder :: Eq a => AppliedParamsList a -> [a] -> [VerifyOrderResult a]
-+collectUnExpectedOrder :: ParamsEq a => AppliedParamsList a -> [a] -> [VerifyOrderResult a]
- collectUnExpectedOrder appliedValues expectedValues =
-   catMaybes $
-     mapWithIndex
-       ( \i expectedValue -> do
-           let appliedValue = appliedValues !! i
--          guard $ expectedValue /= appliedValue
-+          guard $ not (paramsEq expectedValue appliedValue)
-           pure VerifyOrderResult {index = i, appliedValue, expectedValue}
-       )
-       expectedValues
-@@ -273,7 +272,7 @@ mapWithIndex f xs = [f i x | (i, x) <- zip [0 ..] xs]
- -- | Verify that the function has been applied to the expected arguments at least the expected number of times.
- shouldApplyTimesGreaterThanEqual ::
-   ( VerifyCount CountVerifyMethod params a
--  , Eq params
-+  , ParamsEq params
-   , MockResolvable m
-   , ResolvableParams m ~ params
-   , HasCallStack
-@@ -287,7 +286,7 @@ shouldApplyTimesGreaterThanEqual m i = shouldApplyTimes m (GreaterThanEqual i)
- -- | Verify that the function is applied to the expected arguments less than or equal to the expected number of times.
- shouldApplyTimesLessThanEqual ::
-   ( VerifyCount CountVerifyMethod params a
--  , Eq params
-+  , ParamsEq params
-   , MockResolvable m
-   , ResolvableParams m ~ params
-   , HasCallStack
-@@ -301,7 +300,7 @@ shouldApplyTimesLessThanEqual m i = shouldApplyTimes m (LessThanEqual i)
- -- | Verify that the function has been applied to the expected arguments a greater number of times than expected.
- shouldApplyTimesGreaterThan ::
-   ( VerifyCount CountVerifyMethod params a
--  , Eq params
-+  , ParamsEq params
-   , MockResolvable m
-   , ResolvableParams m ~ params
-   , HasCallStack
-@@ -315,7 +314,7 @@ shouldApplyTimesGreaterThan m i = shouldApplyTimes m (GreaterThan i)
- -- | Verify that the function has been applied to the expected arguments less than the expected number of times.
- shouldApplyTimesLessThan ::
-   ( VerifyCount CountVerifyMethod params a
--  , Eq params
-+  , ParamsEq params
-   , MockResolvable m
-   , ResolvableParams m ~ params
-   , HasCallStack
diff --git a/src/Test/MockCat/Cons.hs b/src/Test/MockCat/Cons.hs
index 84aa128..b3fb7ef 100644
--- a/src/Test/MockCat/Cons.hs
+++ b/src/Test/MockCat/Cons.hs
@@ -1,6 +1,6 @@
 {-# LANGUAGE TypeOperators #-}
 {-# LANGUAGE DataKinds #-}
-module Test.MockCat.Cons ((:>)(..)) where
+module Test.MockCat.Cons ((:>)(..), Head(..)) where
 
 data a :> b = a :> b
 
@@ -11,3 +11,9 @@ instance (Eq a, Eq b) => Eq (a :> b) where
   (a :> b) == (a2 :> b2) = (a == a2) && (b == b2)
 
 infixr 8 :>
+
+-- | Marker type for constant value mock functions.
+--   Used to distinguish constant values (Head :> Param r) from
+--   regular mock functions (Param a :> rest).
+data Head = Head
+  deriving (Eq, Show)
diff --git a/src/Test/MockCat/Internal/Builder.hs b/src/Test/MockCat/Internal/Builder.hs
index a731916..f0ec0d9 100644
--- a/src/Test/MockCat/Internal/Builder.hs
+++ b/src/Test/MockCat/Internal/Builder.hs
@@ -20,7 +20,7 @@ module Test.MockCat.Internal.Builder where
 
 import Data.IORef (IORef, newIORef, readIORef, atomicModifyIORef')
 import Data.Maybe
-import Test.MockCat.Cons
+import Test.MockCat.Cons (Head(..), (:>)(..))
 import Test.MockCat.Param
 import Test.MockCat.AssociationList (lookup, update, insert, empty, member)
 import Prelude hiding (lookup)
@@ -125,7 +125,20 @@ instance
         verifier = Verifier ref
     pure (fn, verifier)
 
--- | Instance for building a stub for a value.
+-- | Instance for building a stub for a constant value (with Head marker).
+instance
+  MockBuilder (Head :> Param r) r ()
+  where
+  build _ (Head :> params) = do
+    ref <- liftIO $ newIORef appliedRecord
+    let v = value params
+        fn = perform $ do
+          liftIO $ appendAppliedParams ref ()
+          pure v
+        verifier = Verifier ref
+    pure (fn, verifier)
+
+-- | Instance for building a stub for a value (backward compatibility).
 instance
   MockBuilder (Param r) r ()
   where
diff --git a/src/Test/MockCat/Mock.hs b/src/Test/MockCat/Mock.hs
index 6c8e0ee..e0ce56a 100644
--- a/src/Test/MockCat/Mock.hs
+++ b/src/Test/MockCat/Mock.hs
@@ -23,10 +23,9 @@ module Test.MockCat.Mock
   , buildIO
   , createMockFn
   , createNamedMockFn
+  , createNamedMockFnWithParams
   , createMockFnIO
   , createStubFn
-  , createConstantMockFn
-  , createNamedConstantMockFn
   , shouldApplyTo
   , shouldApplyTimes
   , shouldApplyInOrder
@@ -66,8 +65,88 @@ import Test.MockCat.Internal.Registry
 import Test.MockCat.Internal.Types
 import Test.MockCat.Param
 import Test.MockCat.Verify
+import Test.MockCat.Cons (Head(..), (:>)(..))
 import Type.Reflection (TyCon, splitApps, typeRep, typeRepTyCon)
 
+-- | Type family to convert raw values to mock parameters.
+--   Raw values (like "foo") are converted to Head :> Param a,
+--   while existing Param chains remain unchanged.
+type family ToMockParams p where
+  ToMockParams (Param a :> rest) = Param a :> rest  -- Already a Param chain, keep as is
+  ToMockParams (Param a) = Param a                  -- Single Param, keep as is
+  ToMockParams (Cases a b) = Cases a b              -- Cases, keep as is
+  ToMockParams (IO a) = IO a                        -- IO, keep as is
+  ToMockParams (Head :> a) = Head :> a              -- Already has Head, keep as is
+  ToMockParams a = Head :> Param a                  -- Raw value, wrap with Head :> Param
+
+-- | Type class for converting values to mock parameters.
+class CreateMock p where
+  toParams :: p -> ToMockParams p
+
+-- Instance for Param chains (most specific - should match first)
+instance {-# OVERLAPPING #-} CreateMock (Param a :> rest) where
+  toParams = id
+
+-- Instance for single Param
+instance {-# OVERLAPPING #-} CreateMock (Param a) where
+  toParams = id
+
+-- Instance for Cases
+instance {-# OVERLAPPING #-} CreateMock (Cases a b) where
+  toParams = id
+
+-- Instance for IO
+instance {-# OVERLAPPING #-} CreateMock (IO a) where
+  toParams = id
+
+-- Instance for Head :> Param r (constant values)
+instance {-# OVERLAPPING #-} CreateMock (Head :> Param r) where
+  toParams = id
+
+-- Instance for raw values (fallback)
+-- This handles raw values by wrapping them with Head :> Param
+-- We need to ensure this doesn't match Param chains, Cases, IO, or Head types
+instance {-# OVERLAPPABLE #-} 
+  ( ToMockParams b ~ (Head :> Param b)
+  , Typeable b
+  ) => CreateMock b where
+  toParams value = Head :> param value
+
+-- | Type class for converting values to mock parameters (named version).
+class CreateNamedMock p where
+  toParamsNamed :: p -> ToMockParams p
+
+-- Instance for Param chains
+instance {-# OVERLAPPING #-} CreateNamedMock (Param a :> rest) where
+  toParamsNamed = id
+
+-- Instance for single Param
+instance {-# OVERLAPPING #-} CreateNamedMock (Param a) where
+  toParamsNamed = id
+
+-- Instance for Cases
+instance {-# OVERLAPPING #-} CreateNamedMock (Cases a b) where
+  toParamsNamed = id
+
+-- Instance for IO
+instance {-# OVERLAPPING #-} CreateNamedMock (IO a) where
+  toParamsNamed = id
+
+-- Instance for Head :> Param r (constant values)
+instance {-# OVERLAPPING #-} CreateNamedMock (Head :> Param r) where
+  toParamsNamed = id
+
+-- Instance for raw values (fallback)
+-- This handles raw values by wrapping them with Head :> Param
+-- We need to ensure this doesn't match Param chains, Cases, IO, or Head types
+-- Note: This instance should not match types that already have other instances
+instance {-# OVERLAPPABLE #-} 
+  ( ToMockParams b ~ (Head :> Param b)
+  , Typeable b
+  , b ~ v  -- Add equality constraint to help type inference
+  ) => CreateNamedMock v where
+  toParamsNamed value = Head :> param value
+
 {- | Create a mock function with verification hooks attached.
 
 This function creates a verifiable stub that records argument applications
@@ -77,13 +156,15 @@ appear pure, but it requires 'MonadIO' for creation.
 -}
 createMockFn ::
   ( MonadIO m
-  , MockBuilder params fn verifyParams
+  , CreateMock p
+  , MockBuilder (ToMockParams p) fn verifyParams
   , Typeable verifyParams
   , Typeable fn
   ) =>
-  params ->
+  p ->
   m fn
-createMockFn params = do
+createMockFn p = do
+  let params = toParams p
   (fn, verifier) <- build Nothing params
   registerStub Nothing verifier fn
 
@@ -96,37 +177,33 @@ appear pure, but it requires 'MonadIO' for creation.
 -}
 createNamedMockFn ::
   ( MonadIO m
-  , MockBuilder params fn verifyParams
+  , CreateNamedMock p
+  , MockBuilder (ToMockParams p) fn verifyParams
   , Typeable verifyParams
   , Typeable fn
   ) =>
   MockName ->
-  params ->
+  p ->
   m fn
-createNamedMockFn name params = do
+createNamedMockFn name p = do
+  let params = toParamsNamed p
   (fn, verifier) <- build (Just name) params
   registerStub (Just name) verifier fn
 
-{- | Create a constant mock function with verification hooks attached. -}
-createConstantMockFn ::
-  ( MonadIO m
-  , MockBuilder (Param b) b ()
-  , Typeable b
-  ) =>
-  b ->
-  m b
-createConstantMockFn value = createMockFn (param value)
-
-{- | Create a named constant mock function. -}
-createNamedConstantMockFn ::
+-- | Internal function for TH code that already has MockBuilder constraint.
+--   This avoids CreateNamedMock instance resolution issues in generated code.
+createNamedMockFnWithParams ::
   ( MonadIO m
-  , MockBuilder (Param b) b ()
-  , Typeable b
+  , MockBuilder params fn verifyParams
+  , Typeable verifyParams
+  , Typeable fn
   ) =>
   MockName ->
-  b ->
-  m b
-createNamedConstantMockFn name value = createNamedMockFn name (param value)
+  params ->
+  m fn
+createNamedMockFnWithParams name params = do
+  (fn, verifier) <- build (Just name) params
+  registerStub (Just name) verifier fn
 
 {- | Create a mock function whose result lives in another monad.
 
diff --git a/src/Test/MockCat/Param.hs b/src/Test/MockCat/Param.hs
index 1c24a8f..f13fc1e 100644
--- a/src/Test/MockCat/Param.hs
+++ b/src/Test/MockCat/Param.hs
@@ -31,7 +31,7 @@ module Test.MockCat.Param
   )
 where
 
-import Test.MockCat.Cons ((:>) (..))
+import Test.MockCat.Cons ((:>) (..), Head(..))
 import Unsafe.Coerce (unsafeCoerce)
 import Prelude hiding (any)
 import Data.Typeable (Typeable, typeOf)
@@ -126,6 +126,7 @@ expect_ f = ExpectCondition f "[some condition]"
 
 -- | The type of the argument parameters of the parameters.
 type family ArgsOf params where
+  ArgsOf (Head :> Param r) = ()                        -- Constant value has no arguments
   ArgsOf (Param a :> Param r) = Param a
   ArgsOf (Param a :> rest) = Param a :> ArgsOf rest
 
@@ -133,6 +134,9 @@ type family ArgsOf params where
 class ProjectionArgs params where
   projArgs :: params -> ArgsOf params
 
+instance {-# OVERLAPPING #-} ProjectionArgs (Head :> Param r) where
+  projArgs (_ :> _) = ()
+
 instance {-# OVERLAPPING #-} ProjectionArgs (Param a :> Param r) where
   projArgs (a :> _) = a
 
@@ -144,12 +148,16 @@ instance
 
 -- | The type of the return parameter of the parameters.
 type family ReturnOf params where
+  ReturnOf (Head :> Param r) = Param r                 -- Constant value returns Param r
   ReturnOf (Param a :> Param r) = Param r
   ReturnOf (Param a :> rest) = ReturnOf rest
 
 class ProjectionReturn param where
   projReturn :: param -> ReturnOf param
 
+instance {-# OVERLAPPING #-} ProjectionReturn (Head :> Param r) where
+  projReturn (_ :> r) = r
+
 instance {-# OVERLAPPING #-} ProjectionReturn (Param a :> Param r) where
   projReturn (_ :> r) = r
 
diff --git a/src/Test/MockCat/TH/FunctionBuilder.hs b/src/Test/MockCat/TH/FunctionBuilder.hs
index f932693..db5e232 100644
--- a/src/Test/MockCat/TH/FunctionBuilder.hs
+++ b/src/Test/MockCat/TH/FunctionBuilder.hs
@@ -1,4 +1,5 @@
 {-# LANGUAGE TemplateHaskell #-}
+{-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE GADTs #-}
 {-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE LambdaCase #-}
@@ -49,7 +50,8 @@ import Language.Haskell.TH
   )
 import Language.Haskell.TH.Lib
 import Language.Haskell.TH.Syntax (nameBase, Specificity (SpecifiedSpec))
-import Test.MockCat.Mock ( createNamedMockFn, createNamedConstantMockFn, MockBuilder )
+import Test.MockCat.Mock ( createNamedMockFnWithParams, MockBuilder )
+import Test.MockCat.Cons (Head(..), (:>)(..))
 import Test.MockCat.MockT
   ( MockT (..),
     Definition (..),
@@ -72,14 +74,14 @@ import Test.MockCat.Verify (ResolvableParamsOf, ResolvableParams, resolveForVeri
 import Data.Maybe (fromMaybe)
 import Data.Function ((&))
 import Data.Proxy (Proxy(..))
-import Data.List (find, nub)
+import Data.List (find, nub, nubBy)
 import Data.Typeable (Typeable)
+import Language.Haskell.TH.Ppr (pprint)
 import Unsafe.Coerce (unsafeCoerce)
 import GHC.TypeLits (KnownSymbol, symbolVal)
 
 -- copy of createMockBuilder functions
-import Test.MockCat.Cons ((:>))
-import Test.MockCat.Param (Param)
+import Test.MockCat.Param (Param, param)
 import Test.MockCat.TH.Types (MockOptions(..))
 
 createMockBuilderVerifyParams :: Type -> Type
@@ -121,6 +123,20 @@ partialAdditionalPredicates funType verifyParams =
       | not (null (collectTypeVars funType))
       ]
 
+-- remove Typeable () (unit) and duplicate preds (comparing pretty-printed)
+filterTypeablePreds :: [Pred] -> [Pred]
+filterTypeablePreds preds =
+  nubBy (\a b -> pprint a == pprint b) $ filter (not . isUnitTypePred) preds
+
+isUnitTypePred :: Pred -> Bool
+isUnitTypePred (AppT (ConT _) t) = isUnitType t
+isUnitTypePred _ = False
+
+isUnitType :: Type -> Bool
+isUnitType (TupleT 0) = True
+isUnitType (ParensT t) = isUnitType t
+isUnitType _ = False
+
 -- The following are copies of the function generation utilities from TH.hs
 
 data MockFnContext = MockFnContext
@@ -189,34 +205,43 @@ doCreateMockFnDecs :: (Quote m) => MockType -> String -> Name -> Name -> Type ->
 doCreateMockFnDecs mockType funNameStr mockFunName params funType monadVarName updatedType = do
   newFunSig <- do
     let verifyParams = createMockBuilderVerifyParams updatedType
-        baseCtx =
-          [ AppT (AppT (AppT (ConT ''MockBuilder) (VarT params)) funType) verifyParams
-          , AppT (ConT ''MonadIO) (VarT monadVarName)
+        mockBuilderPred =
+          AppT (AppT (AppT (ConT ''MockBuilder) (VarT params)) funType) verifyParams
+        eqConstraint =
+          [ AppT
+              (AppT EqualityT (AppT (ConT ''ResolvableParamsOf) funType))
+              verifyParams
+          | not (null (collectTypeVars funType))
           ]
+        baseCtx =
+          ([mockBuilderPred | verifyParams /= TupleT 0])
+            ++ [AppT (ConT ''MonadIO) (VarT monadVarName)]
         ctx = case mockType of
           Partial ->
             baseCtx ++ partialAdditionalPredicates funType verifyParams
           Total ->
-            let typeableTargets =
+            let typeableTargetsBase =
                   [ funType
                   , verifyParams
-                  , AppT (ConT ''ResolvableParams) funType
                   ]
+                typeableTargets =
+                  typeableTargetsBase
+                    ++ (if null eqConstraint then [AppT (ConT ''ResolvableParams) funType] else [])
                 typeablePreds =
                   [ AppT (ConT ''Typeable) target
                   | target <- typeableTargets
                   , needsTypeable target
                   ]
-             in baseCtx ++ typeablePreds
+             in baseCtx ++ eqConstraint ++ filterTypeablePreds typeablePreds
         resultType =
           AppT
             (AppT ArrowT (VarT params))
             (AppT (AppT (ConT ''MockT) (VarT monadVarName)) (TupleT 0))
     sigD mockFunName (pure (ForallT [] ctx resultType))
 
-  createMockFn <- [|createNamedMockFn|]
+  createMockFn <- [|createNamedMockFnWithParams|]
 
-  mockBody <- createMockBody funNameStr createMockFn
+  mockBody <- createMockBody funNameStr createMockFn [|p|]
   newFun <- funD mockFunName [clause [varP $ mkName "p"] (normalB (pure mockBody)) []]
 
   pure $ newFunSig : [newFun]
@@ -225,11 +250,11 @@ doCreateConstantMockFnDecs :: (Quote m) => MockType -> String -> Name -> Type ->
 doCreateConstantMockFnDecs Partial funNameStr mockFunName _ monadVarName = do
   stubVar <- newName "r"
   let ctx =
-        [ AppT (ConT ''Typeable) (VarT stubVar)
-        , AppT
+        [ AppT
             (AppT EqualityT (AppT (ConT ''ResolvableParamsOf) (VarT stubVar)))
             (TupleT 0)
         , AppT (ConT ''MonadIO) (VarT monadVarName)
+        , AppT (ConT ''Typeable) (VarT stubVar)
         ]
       resultType =
         AppT
@@ -247,29 +272,64 @@ doCreateConstantMockFnDecs Partial funNameStr mockFunName _ monadVarName = do
               resultType
           )
       )
-  createMockFn <- [|createNamedConstantMockFn|]
-  mockBody <- createMockBody funNameStr createMockFn
+  createMockFn <- [|createNamedMockFnWithParams|]
+  headParam <- [|Head :> param p|]
+  mockBody <- createMockBody funNameStr createMockFn (pure headParam)
   newFun <- funD mockFunName [clause [varP $ mkName "p"] (normalB (pure mockBody)) []]
   pure $ newFunSig : [newFun]
 doCreateConstantMockFnDecs Total funNameStr mockFunName ty monadVarName = do
-  let typeableTargets =
-        [ ty
-        , AppT (ConT ''ResolvableParams) ty
-        ]
-      typeablePreds =
-        [ AppT (ConT ''Typeable) target
-        | target <- typeableTargets
-        , needsTypeable target
-        ]
-      ctx =
-        AppT (ConT ''MonadIO) (VarT monadVarName) : typeablePreds
-      resultType =
-        AppT
-          (AppT ArrowT ty)
-          (AppT (AppT (ConT ''MockT) (VarT monadVarName)) (TupleT 0))
-  newFunSig <- sigD mockFunName (pure (ForallT [] ctx resultType))
-  createMockFn <- [|createNamedConstantMockFn|]
-  mockBody <- createMockBody funNameStr createMockFn
+  newFunSig <- case ty of
+    AppT (ConT _) (VarT mv) | mv == monadVarName -> do
+      a <- newName "a"
+      let ctx =
+            [ AppT (ConT ''MonadIO) (VarT monadVarName)
+            , AppT (AppT EqualityT (AppT (ConT ''ResolvableParamsOf) (VarT a))) (TupleT 0)
+            , AppT (ConT ''Typeable) (VarT a)
+            ]
+          resultType =
+            AppT
+              (AppT ArrowT (VarT a))
+              (AppT (AppT (ConT ''MockT) (VarT monadVarName)) (TupleT 0))
+      sigD
+        mockFunName
+        ( pure
+            (ForallT
+                [PlainTV a SpecifiedSpec, PlainTV monadVarName SpecifiedSpec]
+                ctx
+                resultType
+            )
+        )
+    _ -> do
+      let headParamType = AppT (AppT (ConT ''(:>)) (ConT ''Head)) (AppT (ConT ''Param) ty)
+          typeableTargets =
+            [ ty
+            , AppT (ConT ''ResolvableParams) ty
+            ]
+          typeablePreds =
+            [ AppT (ConT ''Typeable) target
+            | target <- typeableTargets
+            , needsTypeable target
+            ]
+          verifyParams' = createMockBuilderVerifyParams ty
+          mockBuilderPred' = AppT (AppT (AppT (ConT ''MockBuilder) headParamType) ty) (TupleT 0)
+          typeablePreds' =
+            [ AppT (ConT ''Typeable) ty
+            | needsTypeable ty
+            ]
+            ++ typeablePreds
+          ctx =
+            [ AppT (ConT ''MonadIO) (VarT monadVarName)
+            ]
+            ++ ([mockBuilderPred' | verifyParams' /= TupleT 0])
+            ++ typeablePreds'
+          resultType =
+            AppT
+              (AppT ArrowT ty)
+              (AppT (AppT (ConT ''MockT) (VarT monadVarName)) (TupleT 0))
+      sigD mockFunName (pure (ForallT [PlainTV monadVarName SpecifiedSpec] ctx resultType))
+  createMockFn <- [|createNamedMockFnWithParams|]
+  headParam <- [|Head :> param p|]
+  mockBody <- createMockBody funNameStr createMockFn (pure headParam)
   newFun <- funD mockFunName [clause [varP $ mkName "p"] (normalB (pure mockBody)) []]
   pure $ newFunSig : [newFun]
 
@@ -287,29 +347,30 @@ doCreateEmptyVerifyParamMockFnDecs funNameStr mockFunName params funType monadVa
           | target <- typeableTargets
           , needsTypeable target
           ]
+        mockBuilderPred = AppT (AppT (AppT (ConT ''MockBuilder) (VarT params)) funType) verifyParams
         ctx =
-          [ AppT (AppT (AppT (ConT ''MockBuilder) (VarT params)) funType) verifyParams
-          , AppT (ConT ''MonadIO) (VarT monadVarName)
-          ]
-            ++ typeablePreds
+          [mockBuilderPred]
+            ++ [AppT (ConT ''MonadIO) (VarT monadVarName)]
+            ++ filterTypeablePreds typeablePreds
         resultType =
           AppT
             (AppT ArrowT (VarT params))
             (AppT (AppT (ConT ''MockT) (VarT monadVarName)) (TupleT 0))
     sigD mockFunName (pure (ForallT [] ctx resultType))
 
-  createMockFn <- [|createNamedMockFn|]
+  createMockFn <- [|createNamedMockFnWithParams|]
 
-  mockBody <- createMockBody funNameStr createMockFn
+  mockBody <- createMockBody funNameStr createMockFn [|p|]
   newFun <- funD mockFunName [clause [varP $ mkName "p"] (normalB (pure mockBody)) []]
 
   pure $ newFunSig : [newFun]
 
-createMockBody :: (Quote m) => String -> Exp -> m Exp
-createMockBody funNameStr createMockFn =
+createMockBody :: (Quote m) => String -> Exp -> m Exp -> m Exp
+createMockBody funNameStr createMockFn paramsExp =
+  paramsExp >>= \params ->
   [|
     MockT $ do
-      mockInstance <- liftIO $ $(pure createMockFn) $(litE (stringL funNameStr)) p
+      mockInstance <- liftIO $ $(pure createMockFn) $(litE (stringL funNameStr)) $(pure params)
       resolved <- liftIO do
         resolveForVerification mockInstance >>= \case
           Just (maybeName, verifier) -> pure $ ResolvedMock maybeName verifier
diff --git a/test/Property/ParamSpecNormalizeProp.hs b/test/Property/ParamSpecNormalizeProp.hs
index fe033f7..f04a5eb 100644
--- a/test/Property/ParamSpecNormalizeProp.hs
+++ b/test/Property/ParamSpecNormalizeProp.hs
@@ -1,8 +1,6 @@
 {-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE FlexibleInstances #-}
-{-# LANGUAGE PackageImports #-}
 {-# LANGUAGE GADTs #-}
-{-# LANGUAGE MonoLocalBinds #-}
 module Property.ParamSpecNormalizeProp (spec, prop_enum_duplicate_equivalence) where
 
 import Test.Hspec
@@ -10,7 +8,6 @@ import Test.QuickCheck
 import Data.List (nub)
 import Support.ParamSpec (ParamSpec(..))
 import Support.ParamSpecNormalize
-import Data.Hashable (Hashable)
 
 -- Generator for small ParamSpec Int
 -- Avoid empty enum (library contract), but include duplicates.
@@ -29,8 +26,7 @@ genParamSpecInt = frequency
       xs <- vectorOf n smallInt
       pure (PSEnum xs)
     rangeSpec = do
-      a <- smallInt; b <- smallInt
-      pure (PSRangeInt a b)
+      a <- smallInt; PSRangeInt a <$> smallInt
 
 pretty :: ParamSpec Int -> String
 pretty ps = case ps of
@@ -83,5 +79,5 @@ prop_enum_duplicate_equivalence = forAll genDupEnum $ \(xs :: [Int]) ->
       baseLen <- choose (1,5)
       base <- vectorOf baseLen (choose (-5,5))
       dupFactor <- choose (0,3)
-      extras <- concat <$> mapM (\v -> vectorOf dupFactor (pure v)) base
+      extras <- concat <$> mapM (vectorOf dupFactor . pure) base
       shuffle (base ++ extras)
diff --git a/test/Property/ParamSpecRangeMergeRandomProp.hs b/test/Property/ParamSpecRangeMergeRandomProp.hs
index 69b9d75..0bda420 100644
--- a/test/Property/ParamSpecRangeMergeRandomProp.hs
+++ b/test/Property/ParamSpecRangeMergeRandomProp.hs
@@ -1,6 +1,4 @@
-{-# LANGUAGE PackageImports #-}
 {-# LANGUAGE GADTs #-}
-{-# LANGUAGE MonoLocalBinds #-}
 module Property.ParamSpecRangeMergeRandomProp (spec) where
 
 import Test.Hspec
@@ -13,21 +11,21 @@ spec :: Spec
 spec = describe "ParamSpec Int range merge randomized" $ do
   it "acceptance equivalence on sampled domain" $ property prop_range_merge_acceptance
 
-newtype PSList = PSList { unPSList :: [ParamSpec Int] }
+newtype PSList = PSList [ParamSpec Int]
 instance Show PSList where show _ = "<ParamSpec Int list>"
 
 prop_range_merge_acceptance :: Property
 prop_range_merge_acceptance = forAll genPSList $ \(PSList ps) ->
   forAll sampleDomain $ \xs ->
     let n = normaliseManyInt ps
-    in conjoin [ acceptsNormal n x === any (\p -> acceptsParamSpec p x) ps | x <- xs ]
+    in conjoin [ acceptsNormal n x === any (`acceptsParamSpec` x) ps | x <- xs ]
   where
     genPSList = PSList <$> genParamSpecs
     genParamSpecs = sized $ \sz -> do
       k <- choose (0, min 8 (sz+2))
       vectorOf k genOne
     genOne = frequency
-      [ (4, do l <- small; h <- small; pure (PSRangeInt l h))
+      [ (4, do l <- small; PSRangeInt l <$> small;)
       , (1, PSExact <$> small)
       ]
     small = choose (-20,20)
diff --git a/test/Test/MockCat/ExampleSpec.hs b/test/Test/MockCat/ExampleSpec.hs
index 8a63277..ef94833 100644
--- a/test/Test/MockCat/ExampleSpec.hs
+++ b/test/Test/MockCat/ExampleSpec.hs
@@ -1,6 +1,7 @@
 {-# LANGUAGE BlockArguments #-}
 {-# LANGUAGE TemplateHaskell #-}
 {-# LANGUAGE TypeApplications #-}
+{-# LANGUAGE TypeOperators #-}
 {-# OPTIONS_GHC -Wno-name-shadowing #-}
 {-# LANGUAGE DataKinds #-}
 {-# LANGUAGE FlexibleContexts #-}
diff --git a/test/Test/MockCat/MockSpec.hs b/test/Test/MockCat/MockSpec.hs
index 17982bf..cd354e3 100644
--- a/test/Test/MockCat/MockSpec.hs
+++ b/test/Test/MockCat/MockSpec.hs
@@ -889,47 +889,47 @@ spec = do
 
   describe "constant" do
     it "createConstantMock" do
-      f <- createConstantMockFn "foo"
+      f <- createMockFn "foo"
       f `shouldBe` "foo"
       shouldApplyToAnything f
 
     it "createNamedConstantMock" do
-      f <- createNamedConstantMockFn "const" "foo"
+      f <- createNamedMockFn "const" "foo"
       f `shouldBe` "foo"
       shouldApplyToAnything f
 
     it "createConstantMock (error message)" do
-      f <- createConstantMockFn "foo"
+      f <- createMockFn "foo"
       shouldApplyToAnything f `shouldThrow` errorCall "It has never been applied function"
 
     it "createNamedConstantMock (error message)" do
-      f <- createNamedConstantMockFn "constant" "foo"
+      f <- createNamedMockFn "constant" "foo"
       shouldApplyToAnything f `shouldThrow` errorCall "It has never been applied function `constant`"
 
     -- TODO: Fix this test
     -- it "createConstantMock with shouldApplyTimesToAnything (success)" do
-    --   f <- createConstantMockFn "foo"
+    --   f <- createMockFn "foo"
     --   _ <- print f
     --   _ <- print f
     --   _ <- print f
     --   f `shouldApplyTimesToAnything` 3
 
     it "createConstantMock with shouldApplyTimesToAnything (failure)" do
-      f <- createConstantMockFn "foo"
+      f <- createMockFn "foo"
       _ <- evaluate f
       _ <- evaluate f
       f `shouldApplyTimesToAnything` 3 `shouldThrow` anyErrorCall
 
     -- TODO: Fix this test
     -- it "createNamedConstantMock with shouldApplyTimesToAnything (success)" do
-    --   f <- createNamedConstantMockFn "const" "foo"
+    --   f <- createNamedMockFn "const" "foo"
     --   _ <- f `shouldBe` "foo"
     --   _ <- f `shouldBe` "foo"
     --   _ <- f `shouldBe` "foo"
     --   f `shouldApplyTimesToAnything` 3
 
     it "createNamedConstantMock with shouldApplyTimesToAnything (failure)" do
-      f <- createNamedConstantMockFn "const" "foo"
+      f <- createNamedMockFn "const" "foo"
       _ <- evaluate f
       _ <- evaluate f
       f `shouldApplyTimesToAnything` 3 `shouldThrow` anyErrorCall
diff --git a/test/Test/MockCat/PartialMockSpec.hs b/test/Test/MockCat/PartialMockSpec.hs
index 0c0fe22..7380848 100644
--- a/test/Test/MockCat/PartialMockSpec.hs
+++ b/test/Test/MockCat/PartialMockSpec.hs
@@ -120,7 +120,7 @@ _readFile ::
   params ->
   MockT m ()
 _readFile p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "readFile" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "readFile" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -136,7 +136,7 @@ _writeFile ::
   params ->
   MockT m ()
 _writeFile p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "writeFile" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "writeFile" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -146,14 +146,13 @@ _writeFile p = MockT $ do
   addDefinition (Definition (Proxy :: Proxy "writeFile") mockInstance verifyStub)
 
 _getInput ::
-  ( Typeable r
-  , Verify.ResolvableParamsOf r ~ ()
+  ( Verify.ResolvableParamsOf r ~ ()
   , MonadIO m
-  ) =>
-  r ->
+  , Typeable r
+  ) =>r ->
   MockT m ()
 _getInput value = MockT $ do
-  mockInstance <- liftIO $ createNamedConstantMockFn "getInput" value
+  mockInstance <- liftIO $ createNamedMockFnWithParams "getInput" (Head :> param value)
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -165,13 +164,13 @@ _getInput value = MockT $ do
 _toUserInput ::
   ( MockBuilder params (String -> m (Maybe UserInput)) (Param String)
   , MonadIO m
-  , Typeable m
+  , Typeable (String -> m (Maybe UserInput))
   , Verify.ResolvableParamsOf (String -> m (Maybe UserInput)) ~ Param String
   ) =>
   params ->
   MockT m ()
 _toUserInput p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "toUserInput" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "toUserInput" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -183,13 +182,13 @@ _toUserInput p = MockT $ do
 _getByPartial ::
   ( MockBuilder params (String -> m Int) (Param String)
   , MonadIO m
-  , Typeable m
+  , Typeable (String -> m Int)
   , Verify.ResolvableParamsOf (String -> m Int) ~ Param String
   ) =>
   params ->
   MockT m ()
 _getByPartial p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "getBy" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "getBy" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -201,13 +200,13 @@ _getByPartial p = MockT $ do
 _echoPartial ::
   ( MockBuilder params (String -> m ()) (Param String)
   , MonadIO m
-  , Typeable m
+  , Typeable (String -> m ())
   , Verify.ResolvableParamsOf (String -> m ()) ~ Param String
   ) =>
   params ->
   MockT m ()
 _echoPartial p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "echo" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "echo" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -240,14 +239,13 @@ instance (MonadIO m, Finder a b m) => Finder a b (MockT m) where
       Nothing -> lift $ findById id
 
 _findIds ::
-  ( Typeable r
-  , Verify.ResolvableParamsOf r ~ ()
+  ( Verify.ResolvableParamsOf r ~ ()
   , MonadIO m
-  ) =>
-  r ->
+  , Typeable r
+  ) =>r ->
   MockT m ()
 _findIds p = MockT $ do
-  mockInstance <- liftIO $ createNamedConstantMockFn "_findIds" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_findIds" (Head :> param p)
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
diff --git a/test/Test/MockCat/PartialMockTHSpec.hs b/test/Test/MockCat/PartialMockTHSpec.hs
index c020b05..f4e79d4 100644
--- a/test/Test/MockCat/PartialMockTHSpec.hs
+++ b/test/Test/MockCat/PartialMockTHSpec.hs
@@ -88,7 +88,7 @@ spec = do
 
     describe "MultiParamType" $ do
       it "all real function" $ do
-        values <- runMockT $ findValue
+        values <- runMockT findValue
         values `shouldBe` ["{id: 1}", "{id: 2}", "{id: 3}"]
 
       it "partial findIds" $ do
diff --git a/test/Test/MockCat/THCompareSpec.hs b/test/Test/MockCat/THCompareSpec.hs
index 4e4ba0d..6c17a19 100644
--- a/test/Test/MockCat/THCompareSpec.hs
+++ b/test/Test/MockCat/THCompareSpec.hs
@@ -11,7 +11,7 @@ import Test.Hspec
 import Language.Haskell.TH (pprint, Dec(..), Type(..), litE, stringL, listE, tupE)
 import Language.Haskell.TH.Syntax (nameBase)
 import Data.Char (isDigit, isLower)
-import Data.List (foldl', sort)
+import Data.List (foldl', sort, nub)
 import Data.Maybe (mapMaybe)
 import qualified Data.Map.Strict as Map
 import qualified Data.Text as T
@@ -38,6 +38,9 @@ stripQualifiers =
       T.pack
       [ "Test.MockCat.SharedSpecDefs."
       , "Test.MockCat.MockT."
+      , "Test.MockCat.Internal.Builder."
+      , "Test.MockCat.Cons."
+      , "Test.MockCat.Param."
       , "Control.Monad.IO.Class."
       , "GHC.Types."
       , "Data.Typeable.Internal."
@@ -68,7 +71,20 @@ squeezePunctuation =
     , (" ]", "]")
     , (" <" , "<")
     , ("> ", ">")
+    , ("((:>) ", "(")
+    , ("((:>)", "(")
+    , ("(:>) ", "")
+    , ("(:>)", "")
     ]
+  . T.replace (T.pack "Head (Param") (T.pack "Head :>Param")
+  . T.replace (T.pack "Head :> Param") (T.pack "Head :>Param")
+  -- Fix: MockBuilder (Head :>Param r) r () should not become MockBuilder (Head :>Param r r ()
+  -- First fix the case where " r r ()" appears (missing closing paren)
+  . T.replace (T.pack ":>Param r r ()") (T.pack ":>Param r) r ()")
+  . T.replace (T.pack "Head :>Param r r ()") (T.pack "Head :>Param r) r ()")
+  . T.replace (T.pack "Param r r ()") (T.pack "Param r) r ()")
+  -- Then handle the general case of ") r ()" -> " r ()" but only if not already fixed
+  . T.replace (T.pack ") r ()") (T.pack " r ()")
   where
     applyReplacements reps txt =
       foldl'
@@ -166,6 +182,28 @@ generatedAssocTypeStr = $(
       Just n -> do decs <- makeMock (conT n); litE (stringL (concatMap pprint decs))
   )
 
+generatedAssocSigPairs :: [(String, String)]
+generatedAssocSigPairs =
+  $(
+    do
+      m <- lookupTypeName "Test.MockCat.SharedSpecDefs.AssocTypeTest"
+      case m of
+        Nothing -> fail "AssocTypeTest not found"
+        Just n -> do
+          decs <- makeMock (conT n)
+          let sigPairs =
+                [ (nameBase name, pprint ty)
+                | SigD name ty <- decs
+                ]
+          listE
+            [ tupE [litE (stringL fn), litE (stringL sig)]
+            | (fn, sig) <- sigPairs
+            ]
+  )
+
+generatedAssocSigMap :: Map.Map String String
+generatedAssocSigMap = Map.fromList generatedAssocSigPairs
+
 generatedParamThreeStr :: String
 generatedParamThreeStr = $(
   do
@@ -292,6 +330,31 @@ spec = describe "TH generated vs handwritten instances" do
     it desc $
       assertInstancesEquivalent manualPath className generatedStr
 
+  it "generated helper signatures do not contain duplicated Typeable constraints" do
+    let allSigMaps =
+          [ generatedFinderSigMap,
+            generatedUserInputSigMap
+          ]
+        extractTypeableTargets :: String -> [String]
+        extractTypeableTargets s =
+          let go acc txt =
+                let (_, rest) = T.breakOn (T.pack "Typeable") txt
+                 in if T.null rest
+                      then acc
+                      else
+                        let afterTypeable = T.drop (T.length (T.pack "Typeable")) rest
+                            afterTrim = T.stripStart afterTypeable
+                            tok = T.strip $ T.takeWhile (\c -> c /= ',' && c /= ')' && c /= '=') afterTrim
+                            rest' = afterTypeable
+                         in go (acc ++ [T.unpack tok]) rest'
+           in go [] (T.pack s)
+        checkMap m =
+          forM_ (Map.toList m) \(_fn, sig) -> do
+            let nsig = normalizeSignature sig
+                targets = extractTypeableTargets nsig
+            (length targets) `shouldBe` (length (nub targets))
+    mapM_ checkMap allSigMaps
+
   describe "Partial mock helper signatures match handwritten" do
     it "_findIds signature matches handwritten" $
       assertHelperSigMatches partialMockSpecPath generatedFinderSigMap "_findIds"
@@ -306,6 +369,9 @@ spec = describe "TH generated vs handwritten instances" do
           normalizeSignature sig
             `shouldSatisfy` not . T.isInfixOf (T.pack "ResolvableParamsOf") . T.pack
 
+    it "_produce signature matches handwritten" $
+      assertHelperSigMatches typeClassSpecPath generatedAssocSigMap "_produce"
+
 -- helper to extract generated instance headers from a pre-pprinted string
 extractGeneratedInstanceCxtsFromStr :: String -> String -> [String]
 extractGeneratedInstanceCxtsFromStr s =
@@ -395,8 +461,13 @@ normalizeSignature =
     . T.pack
     . dropFunctionName
     . stripForallClause
+    . replaceDoubleParens
     . normalize
 
+-- collapse duplicated closing parens introduced by normalization quirks
+replaceDoubleParens :: String -> String
+replaceDoubleParens = T.unpack . T.replace (T.pack "))") (T.pack ")") . T.pack
+
 dropFunctionName :: String -> String
 dropFunctionName sig =
   let txt = T.pack sig
diff --git a/test/Test/MockCat/TypeClassSpec.hs b/test/Test/MockCat/TypeClassSpec.hs
index d626783..6f0d2d4 100644
--- a/test/Test/MockCat/TypeClassSpec.hs
+++ b/test/Test/MockCat/TypeClassSpec.hs
@@ -93,13 +93,12 @@ instance MonadState s m => MonadState s (MockT m) where
   state f = lift (state f)
 
 _ask ::
-  ( Typeable env
-  , Verify.ResolvableParamsOf env ~ ()
+  ( Verify.ResolvableParamsOf env ~ ()
   , MonadIO m
-  ) =>
-  env -> MockT m ()
+  , Typeable env
+  ) =>env -> MockT m ()
 _ask p = MockT $ do
-  mockInstance <- liftIO $ createNamedConstantMockFn "ask" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "ask" (Head :> param p)
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -115,7 +114,7 @@ _readFile ::
   params ->
   MockT m ()
 _readFile p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "readFile" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "readFile" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -131,7 +130,7 @@ _writeFile ::
   params ->
   MockT m ()
 _writeFile p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "writeFile" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "writeFile" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -147,7 +146,7 @@ _post ::
   params ->
   MockT m ()
 _post p = MockT $ do
-  mockFn <- liftIO $ createNamedMockFn "post" p
+  mockFn <- liftIO $ createNamedMockFnWithParams "post" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockFn
     case result of
@@ -330,7 +329,7 @@ _getBy ::
   params ->
   MockT m ()
 _getBy p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "_getBy" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_getBy" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -348,7 +347,7 @@ _echo ::
   params ->
   MockT m ()
 _echo p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "_echo" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_echo" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -366,7 +365,7 @@ _fn2_1Sub ::
   params ->
   MockT m ()
 _fn2_1Sub p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "_fn2_1Sub" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_fn2_1Sub" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -384,7 +383,7 @@ _fn2_2Sub ::
   params ->
   MockT m ()
 _fn2_2Sub p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "_fn2_2Sub" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_fn2_2Sub" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -402,7 +401,7 @@ _fn3_1Sub ::
   params ->
   MockT m ()
 _fn3_1Sub p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "_fn3_1Sub" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_fn3_1Sub" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -420,7 +419,7 @@ _fn3_2Sub ::
   params ->
   MockT m ()
 _fn3_2Sub p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "_fn3_2Sub" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_fn3_2Sub" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -438,7 +437,7 @@ _fn3_3Sub ::
   params ->
   MockT m ()
 _fn3_3Sub p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "_fn3_3Sub" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_fn3_3Sub" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -456,7 +455,7 @@ _getValueBy ::
   params ->
   MockT m ()
 _getValueBy p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "_getValueBy" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_getValueBy" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -475,7 +474,7 @@ _fnState ::
   params ->
   MockT m ()
 _fnState p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "_fnState" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_fnState" p
   let verifyStub _ = pure ()
   addDefinition (Definition (Proxy :: Proxy "_fnState") mockInstance verifyStub)
 
@@ -488,7 +487,7 @@ _fnState2 ::
   params ->
   MockT m ()
 _fnState2 p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "_fnState2" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_fnState2" p
   let verifyStub _ = pure ()
   addDefinition (Definition (Proxy :: Proxy "_fnState2") mockInstance verifyStub)
 
@@ -501,7 +500,7 @@ _fnParam3_1 ::
   params ->
   MockT m ()
 _fnParam3_1 p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "_fnParam3_1" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_fnParam3_1" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -519,7 +518,7 @@ _fnParam3_2 ::
   params ->
   MockT m ()
 _fnParam3_2 p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "_fnParam3_2" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_fnParam3_2" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -537,7 +536,7 @@ _fnParam3_3 ::
   params ->
   MockT m ()
 _fnParam3_3 p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "_fnParam3_3" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_fnParam3_3" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -555,7 +554,7 @@ _getByExplicit ::
   params ->
   MockT m ()
 _getByExplicit p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "_getByExplicit" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_getByExplicit" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -573,7 +572,7 @@ _echoExplicit ::
   params ->
   MockT m ()
 _echoExplicit p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "_echoExplicit" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_echoExplicit" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -584,13 +583,13 @@ _echoExplicit p = MockT $ do
 
 _defaultAction ::
   ( MonadIO m
-  , Typeable a
   , Verify.ResolvableParamsOf a ~ ()
+  , Typeable a
   ) =>
   a ->
   MockT m ()
 _defaultAction value = MockT $ do
-  mockInstance <- liftIO $ createNamedConstantMockFn "_defaultAction" value
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_defaultAction" (Head :> param value)
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -601,13 +600,13 @@ _defaultAction value = MockT $ do
 
 _produce ::
   ( MonadIO m
-  , Typeable a
   , Verify.ResolvableParamsOf a ~ ()
+  , Typeable a
   ) =>
   a ->
   MockT m ()
 _produce value = MockT $ do
-  mockInstance <- liftIO $ createNamedConstantMockFn "_produce" value
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_produce" (Head :> param value)
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -623,7 +622,7 @@ stubPostFn ::
   params ->
   MockT m ()
 stubPostFn p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "stubPostFn" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "stubPostFn" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -667,7 +666,7 @@ _readTTY ::
   params ->
   MockT m ()
 _readTTY p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "_readTTY" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_readTTY" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
@@ -685,7 +684,7 @@ _writeTTY ::
   params ->
   MockT m ()
 _writeTTY p = MockT $ do
-  mockInstance <- liftIO $ createNamedMockFn "_writeTTY" p
+  mockInstance <- liftIO $ createNamedMockFnWithParams "_writeTTY" p
   resolved <- liftIO $ do
     result <- Verify.resolveForVerification mockInstance
     case result of
diff --git a/test/Test/MockCat/TypeClassTHSpec.hs b/test/Test/MockCat/TypeClassTHSpec.hs
index 7ecf0bd..4e47780 100644
--- a/test/Test/MockCat/TypeClassTHSpec.hs
+++ b/test/Test/MockCat/TypeClassTHSpec.hs
@@ -7,6 +7,7 @@
 {-# LANGUAGE FunctionalDependencies #-}
 {-# LANGUAGE AllowAmbiguousTypes #-}
 {-# LANGUAGE TypeFamilies #-}
+{-# LANGUAGE TypeOperators #-}
 {-# OPTIONS_GHC -Wno-unused-top-binds #-}
 {-# OPTIONS_GHC -Wno-orphans #-}
 {-# OPTIONS_GHC -Wno-name-shadowing #-}
